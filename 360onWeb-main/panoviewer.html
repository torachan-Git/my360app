<!DOCTYPE html>
<!--
360Â° Panorama Viewer / 360åº¦ãƒ‘ãƒãƒ©ãƒãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼

Collaborative work by Junji Ikeda and Claude.ai
All code generated by AI with human guidance and iteration
ã„ã‘ã ã˜ã‚…ã‚“ã˜ã¨Claude.aiã®å”åƒé–‹ç™ºã«ã‚ˆã‚‹ä½œå“ã§ã™ã€‚äººé–“ã¨ AI ã®å¯¾è©±ã‚’é€šã˜ã¦åå¾©æ”¹å–„ã‚’é‡ã­ã¦åˆ¶ä½œã—ã¾ã—ãŸã€‚

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
https://creativecommons.org/publicdomain/zero/1.0/

This work has been released into the public domain by the copyright holder.
This applies worldwide. In some countries this may not be legally possible;
if so: the copyright holder grants anyone the right to use this work for any
purpose, without any conditions, unless such conditions are required by law.

ã“ã®ä½œå“ã¯è‘—ä½œæ¨©è€…ã«ã‚ˆã£ã¦ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ‰ãƒ¡ã‚¤ãƒ³ã«æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã‚Œã¯ä¸–ç•Œä¸­ã§é©ç”¨ã•ã‚Œã¾ã™ã€‚ä¸€éƒ¨ã®å›½ã§ã¯æ³•çš„ã«ä¸å¯èƒ½ãªå ´åˆãŒã‚ã‚Šã¾ã™ã€‚
ãã®å ´åˆã€è‘—ä½œæ¨©è€…ã¯æ³•å¾‹ã§è¦æ±‚ã•ã‚Œã‚‹å ´åˆã‚’é™¤ãã€ã„ã‹ãªã‚‹æ¡ä»¶ã‚‚ãªã—ã«ã€
ã‚ã‚‰ã‚†ã‚‹ç›®çš„ã§ã“ã®ä½œå“ã‚’ä½¿ç”¨ã™ã‚‹æ¨©åˆ©ã‚’èª°ã«ã§ã‚‚ä»˜ä¸ã—ã¾ã™ã€‚

Features / æ©Ÿèƒ½:
- Equirectangular 360Â° image support / ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼360åº¦ç”»åƒå¯¾å¿œ
- High-quality geometric correction / é«˜å“è³ªå¹¾ä½•å­¦çš„æ­ªã¿è£œæ­£
- Drag & drop image loading / ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ç”»åƒèª­ã¿è¾¼ã¿
- Touch and mouse controls / ã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹æ“ä½œå¯¾å¿œ
- Fully client-side processing / å®Œå…¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰å‡¦ç†

Created: 2025 Junji Ikeda
-->


<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360Â° Panorama Viewer</title>
    <meta name="description" content="360åº¦ãƒ‘ãƒãƒ©ãƒç”»åƒãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ - ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼ç”»åƒå¯¾å¿œã€å¹¾ä½•å­¦çš„æ­ªã¿è£œæ­£æ¸ˆã¿">
    <meta name="keywords" content="360åº¦, ãƒ‘ãƒãƒ©ãƒ, ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼, ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼, VR, 360 degree, panorama, viewer, equirectangular">
    <meta name="author" content="Released under CC0 1.0 Universal">
    
    <style>
        /**
         * 360Â° Panorama Viewer Styles
         * CC0 1.0 Universal - Public Domain
         */
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 16px;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.4;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .hidden {
            display: none;
        }
        
        #fileControls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
        }
        
        #fileInput {
            display: none;
        }
        
        #selectButton {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
        }
        
        #selectButton:hover {
            background: linear-gradient(135deg, #0056b3, #004085);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.4);
        }
        
        #selectButton:active {
            transform: translateY(0);
        }
        
        /* ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒªã‚¢ */
        #dropZone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            background: rgba(0, 123, 255, 0.1);
            border: 3px dashed rgba(0, 123, 255, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        #dropZone.show {
            display: flex;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 768px) {
            
            
            #selectButton {
                font-size: 12px;
                padding: 10px 16px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
        
        <div id="info">
            <strong>360Â° Panorama Viewer</strong><br>
        </div>
                
        <div id="fileControls">
            <input type="file" id="fileInput" accept="image/*" />
            <button id="selectButton">360Â°å†™çœŸã‚’é¸æŠ</button>
        </div>
        
        <div id="dropZone">
            <div>
                <div>ğŸ“·</div>
                <div>360Â°å†™çœŸã‚’ã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—</div>
            </div>
        </div>
    </div>

    <!-- Three.js ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        /**
         * 360Â° Panorama Viewer JavaScript
         * CC0 1.0 Universal - Public Domain
         * 
         * This script creates a 360-degree panorama viewer with:
         * - Equirectangular image support
         * - High-quality geometric correction
         * - Touch and mouse controls
         * - Drag & drop functionality
         */
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let scene, camera, renderer;
        let sphere;
        let isMouseDown = false;
        let previousMouseX = 0, previousMouseY = 0;
        let phi = 0, theta = Math.PI / 2; // çƒé¢åº§æ¨™
        let radius = 1;
        
        // ã‚¿ãƒƒãƒæ“ä½œç”¨å¤‰æ•°
        let isTouching = false;
        let isPinching = false;
        let previousTouchX = 0, previousTouchY = 0;
        let previousPinchDistance = 0;

        // é«˜å“è³ªè¨­å®š (256ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ Ã— 128ãƒªãƒ³ã‚°)
        const SPHERE_SEGMENTS = 256;
        const SPHERE_RINGS = 128;
        const SPHERE_RADIUS = 500;
        
        /**
         * ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
         */
        function init() {
            // Three.jsã‚·ãƒ¼ãƒ³è¨­å®š
            scene = new THREE.Scene();
            
            // ã‚«ãƒ¡ãƒ©è¨­å®š
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 0, 0);
            
            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®šï¼ˆé«˜å“è³ªï¼‰
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç”»åƒã‚’è©¦è¡Œï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'sample360.jpg', // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç”»åƒï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ‡ãƒ¢ç”»åƒï¼‰
                function(texture) {
                    setupTexture(texture);
                    createEquirectangularSphere(texture);
                    document.getElementById('loading').classList.add('hidden');
                    animate();
                },
                function(progress) {
                    console.log('Loading progress: ' + (progress.loaded / progress.total * 100) + '%');
                },
                function(error) {
                    console.log('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ¢ç”»åƒã‚’è¡¨ç¤ºã—ã¾ã™ã€‚');
                    createDemoSphere();
                    animate();
                }
            );
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
            setupEventListeners();
            setupFileControls();
            setupDragAndDrop();
            updateCamera();
        }

        /**
         * ãƒ†ã‚¯ã‚¹ãƒãƒ£è¨­å®šã®æœ€é©åŒ–
         */
        function setupTexture(texture) {
            // é«˜å“è³ªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            // ç•°æ–¹æ€§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ã®ã¿ï¼‰
            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.anisotropy = Math.min(16, maxAnisotropy);
            
            // ãƒ©ãƒƒãƒ”ãƒ³ã‚°è¨­å®š
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            
            texture.needsUpdate = true;
            return texture;
        }
        
        /**
         * ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼ç”¨çƒé¢ãƒ¡ãƒƒã‚·ãƒ¥ä½œæˆ
         */
        function createEquirectangularSphere(texture) {
            // æ—¢å­˜ã®çƒä½“ã‚’å‰Šé™¤ï¼ˆãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢ï¼‰
            if (sphere) {
                scene.remove(sphere);
                if (sphere.geometry) sphere.geometry.dispose();
                if (sphere.material && sphere.material.map) sphere.material.map.dispose();
                if (sphere.material) sphere.material.dispose();
            }

            // é«˜å“è³ªã‚¸ã‚ªãƒ¡ãƒˆãƒªä½œæˆ
            const geometry = createEquirectangularGeometry(
                SPHERE_RADIUS, 
                SPHERE_SEGMENTS, 
                SPHERE_RINGS
            );
            
            // ãƒãƒ†ãƒªã‚¢ãƒ«ä½œæˆ
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.BackSide // å†…å´ã‹ã‚‰è¦‹ã‚‹ãŸã‚
            });
            
            // ãƒ¡ãƒƒã‚·ãƒ¥ä½œæˆã¨ã‚·ãƒ¼ãƒ³ã«è¿½åŠ 
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
        }

        /**
         * ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼ç”»åƒç”¨ã®æœ€é©åŒ–ã•ã‚ŒãŸçƒé¢ã‚¸ã‚ªãƒ¡ãƒˆãƒª
         * æ¥µç‚¹ã§ã®å¹¾ä½•å­¦çš„æ­ªã¿ã‚’æœ€å°åŒ–
         */
        function createEquirectangularGeometry(radius, widthSegments, heightSegments) {
            const geometry = new THREE.BufferGeometry();
            
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            
            // é ‚ç‚¹ã¨UVåº§æ¨™ã®ç”Ÿæˆ
            for (let iy = 0; iy <= heightSegments; iy++) {
                const v = iy / heightSegments;
                const phi = v * Math.PI; // ç·¯åº¦è§’: 0(åŒ—æ¥µ) â†’ Ï€(å—æ¥µ)
                
                for (let ix = 0; ix <= widthSegments; ix++) {
                    const u = ix / widthSegments;
                    const theta = u * Math.PI * 2; // çµŒåº¦è§’: 0 â†’ 2Ï€
                    
                    // çƒé¢åº§æ¨™ã‹ã‚‰ç›´äº¤åº§æ¨™ã¸ã®å¤‰æ›
                    const x = -radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.cos(phi);
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    
                    vertices.push(x, y, z);
                    
                    // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
                    const nx = -Math.sin(phi) * Math.cos(theta);
                    const ny = Math.cos(phi);
                    const nz = Math.sin(phi) * Math.sin(theta);
                    normals.push(nx, ny, nz);
                    
                    // UVåº§æ¨™ï¼ˆåè»¢æ¸ˆã¿ï¼‰
                    uvs.push(1 - u, 1 - v);
                }
            }
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç”Ÿæˆï¼ˆæ¥µç‚¹ã§ã®ä¸‰è§’å½¢é€€åŒ–é˜²æ­¢ï¼‰
            for (let iy = 0; iy < heightSegments; iy++) {
                for (let ix = 0; ix < widthSegments; ix++) {
                    const a = iy * (widthSegments + 1) + ix;
                    const b = a + widthSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    if (iy === 0) {
                        // åŒ—æ¥µç‚¹: ä¸Šã®ä¸‰è§’å½¢ã®ã¿
                        indices.push(a, b, d);
                    } else if (iy === heightSegments - 1) {
                        // å—æ¥µç‚¹: ä¸‹ã®ä¸‰è§’å½¢ã®ã¿
                        indices.push(a, b, c);
                    } else {
                        // é€šå¸¸ã®å››è§’å½¢ã‚’2ã¤ã®ä¸‰è§’å½¢ã«åˆ†å‰²
                        indices.push(a, b, c);
                        indices.push(b, d, c);
                    }
                }
            }
            
            // ã‚¸ã‚ªãƒ¡ãƒˆãƒªå±æ€§è¨­å®š
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            
            return geometry;
        }
        
        /**
         * ãƒ‡ãƒ¢ç”¨çƒé¢ä½œæˆï¼ˆ360åº¦ç”»åƒãŒãªã„å ´åˆï¼‰
         */
        function createDemoSphere() {
            const canvas = document.createElement('canvas');
            canvas.width = 4096;  // 4Kè§£åƒåº¦
            canvas.height = 2048; // 2:1 ã‚¨ã‚¯ã‚¤ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ©ãƒ¼æ¯”ç‡
            const context = canvas.getContext('2d');
            
            // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
            const gradient = context.createLinearGradient(0, 0, 0, 2048);
            gradient.addColorStop(0, '#87CEEB');    // å¤©é ‚: ç©ºè‰²
            gradient.addColorStop(0.5, '#32CD32');  // èµ¤é“: ç·‘
            gradient.addColorStop(1, '#8B4513');    // å¤©åº•: èŒ¶è‰²
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 4096, 2048);
            
            // ç·¯åº¦ãƒ»çµŒåº¦ã‚°ãƒªãƒƒãƒ‰æç”»
            context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            context.lineWidth = 3;
            
            // çµŒåº¦ç·šï¼ˆ15åº¦é–“éš”ï¼‰
            for (let i = 0; i <= 24; i++) {
                const x = (4096 / 24) * i;
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, 2048);
                context.stroke();
            }
            
            // ç·¯åº¦ç·šï¼ˆ15åº¦é–“éš”ï¼‰
            for (let i = 0; i <= 12; i++) {
                const y = (2048 / 12) * i;
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(4096, y);
                context.stroke();
            }
            
            // ä¸»è¦ç·šã‚’å¼·èª¿
            context.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            context.lineWidth = 5;
            
            // èµ¤é“ç·š
            context.beginPath();
            context.moveTo(0, 1024);
            context.lineTo(4096, 1024);
            context.stroke();
            
            // æœ¬åˆå­åˆç·š
            context.beginPath();
            context.moveTo(2048, 0);
            context.lineTo(2048, 2048);
            context.stroke();
            
            // èª¬æ˜ãƒ†ã‚­ã‚¹ãƒˆ
            context.fillStyle = 'white';
            context.font = 'bold 72px Arial';
            context.textAlign = 'center';
            context.shadowColor = 'black';
            context.shadowBlur = 8;
            
            context.fillText('â¬†ï¸', 2048, 630);
            context.fillText('ã‚¢ãƒ«ãƒãƒ ã‹ã‚‰', 2048, 896);
            context.fillText('â¬…ï¸ã€€ã€€ã€€360å†™çœŸã‚’ã€€ã€€ã€€â¡ï¸', 2048, 1024);
            context.fillText('é¸æŠã—ã¦ãã ã•ã„', 2048, 1152);
            context.fillText('â¬‡ï¸', 2048, 1406);
            
            const texture = new THREE.CanvasTexture(canvas);
            setupTexture(texture);
            createEquirectangularSphere(texture);
            document.getElementById('loading').classList.add('hidden');
        }
        
        /**
         * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
         */
        function setupEventListeners() {
            const canvas = renderer.domElement;
            
            // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
            canvas.addEventListener('mousedown', onMouseDown, { passive: false });
            canvas.addEventListener('mousemove', onMouseMove, { passive: false });
            canvas.addEventListener('mouseup', onMouseUp, { passive: false });
            canvas.addEventListener('wheel', onMouseWheel, { passive: false });
            
            // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd, { passive: false });
            
            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚º
            window.addEventListener('resize', onWindowResize, false);
            
            // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ç„¡åŠ¹åŒ–
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            }, false);
        }
        
        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function onMouseDown(event) {
            isMouseDown = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
            event.preventDefault();
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;
            
            phi -= deltaX * 0.002;
            theta -= deltaY * 0.002;
            
            // å¤©é ‚ãƒ»å¤©åº•ã®åˆ¶é™
            theta = Math.max(0.01, Math.min(Math.PI - 0.01, theta));
            
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
            
            updateCamera();
            event.preventDefault();
        }
        
        function onMouseUp(event) {
            isMouseDown = false;
            event.preventDefault();
        }
        
        function onMouseWheel(event) {
            const fov = camera.fov + event.deltaY * 0.05;
            camera.fov = Math.max(10, Math.min(120, fov));
            camera.updateProjectionMatrix();
            event.preventDefault();
        }
        
        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                // ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒ: å›è»¢
                isTouching = true;
                isPinching = false;
                previousTouchX = event.touches[0].clientX;
                previousTouchY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                // ãƒ”ãƒ³ãƒ: ã‚ºãƒ¼ãƒ 
                isTouching = false;
                isPinching = true;
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                previousPinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
            event.preventDefault();
        }
        
        function onTouchMove(event) {
            if (isTouching && event.touches.length === 1) {
                // å›è»¢å‡¦ç†
                const deltaX = event.touches[0].clientX - previousTouchX;
                const deltaY = event.touches[0].clientY - previousTouchY;
                
                phi -= deltaX * 0.002;
                theta -= deltaY * 0.002;
                
                theta = Math.max(0.01, Math.min(Math.PI - 0.01, theta));
                
                previousTouchX = event.touches[0].clientX;
                previousTouchY = event.touches[0].clientY;
                
                updateCamera();
            } else if (isPinching && event.touches.length === 2) {
                // ã‚ºãƒ¼ãƒ å‡¦ç†
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);
                
                const pinchDelta = currentPinchDistance - previousPinchDistance;
                const fov = camera.fov - pinchDelta * 0.2;
                camera.fov = Math.max(20, Math.min(135, fov));
                camera.updateProjectionMatrix();
                
                previousPinchDistance = currentPinchDistance;
            }
            event.preventDefault();
        }
        
        function onTouchEnd(event) {
            isTouching = false;
            isPinching = false;
            event.preventDefault();
        }
        
        /**
         * ã‚«ãƒ¡ãƒ©ä½ç½®æ›´æ–°
         */
        function updateCamera() {
            const x = radius * Math.sin(theta) * Math.cos(phi);
            const y = radius * Math.cos(theta);
            const z = radius * Math.sin(theta) * Math.sin(phi);
            
            camera.position.set(0, 0, 0);
            camera.lookAt(x, y, z);
        }
        
        /**
         * ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå‡¦ç†
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        /**
         * ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
         */
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        /**
         * ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«è¨­å®š
         */
        function setupFileControls() {
            const fileInput = document.getElementById('fileInput');
            const selectButton = document.getElementById('selectButton');
            
            selectButton.addEventListener('click', function() {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    loadImageFile(file);
                }
            });
        }
        
        /**
         * ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½è¨­å®š
         */
        function setupDragAndDrop() {
            const container = document.getElementById('container');
            const dropZone = document.getElementById('dropZone');
            let dragCounter = 0;
            
            // ãƒ‰ãƒ©ãƒƒã‚°ã‚¨ãƒ³ã‚¿ãƒ¼
            container.addEventListener('dragenter', function(e) {
                e.preventDefault();
                dragCounter++;
                dropZone.classList.add('show');
            });
            
            // ãƒ‰ãƒ©ãƒƒã‚°ãƒªãƒ¼ãƒ–
            container.addEventListener('dragleave', function(e) {
                e.preventDefault();
                dragCounter--;
                if (dragCounter === 0) {
                    dropZone.classList.remove('show');
                }
            });
            
            // ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼
            container.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            // ãƒ‰ãƒ­ãƒƒãƒ—
            container.addEventListener('drop', function(e) {
                e.preventDefault();
                dragCounter = 0;
                dropZone.classList.remove('show');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    loadImageFile(files[0]);
                }
            });
        }
        
        /**
         * ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
         */
        function loadImageFile(file) {
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('loading').innerHTML = 'ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    e.target.result,
                    function(texture) {
                        setupTexture(texture);
                        createEquirectangularSphere(texture);
                        document.getElementById('loading').classList.add('hidden');
                        
                        // ã‚«ãƒ¡ãƒ©ã‚’ãƒªã‚»ãƒƒãƒˆ
                        phi = 0;
                        theta = Math.PI / 2;
                        camera.fov = 75;
                        camera.updateProjectionMatrix();
                        updateCamera();
                    },
                    undefined,
                    function(error) {
                        console.error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                        document.getElementById('loading').innerHTML = 'ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
                        setTimeout(() => {
                            document.getElementById('loading').classList.add('hidden');
                        }, 2000);
                    }
                );
            };
            
            reader.onerror = function() {
                console.error('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                document.getElementById('loading').innerHTML = 'ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 2000);
            };
            
            reader.readAsDataURL(file);
        }
        
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        init();
    </script>
</body>
</html>