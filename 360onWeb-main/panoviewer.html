<!DOCTYPE html>
<!--
360° Panorama Viewer / 360度パノラマビューアー

Collaborative work by Junji Ikeda and Claude.ai
All code generated by AI with human guidance and iteration
いけだじゅんじとClaude.aiの協働開発による作品です。人間と AI の対話を通じて反復改善を重ねて制作しました。

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
https://creativecommons.org/publicdomain/zero/1.0/

This work has been released into the public domain by the copyright holder.
This applies worldwide. In some countries this may not be legally possible;
if so: the copyright holder grants anyone the right to use this work for any
purpose, without any conditions, unless such conditions are required by law.

この作品は著作権者によってパブリックドメインに提供されています。
これは世界中で適用されます。一部の国では法的に不可能な場合があります。
その場合、著作権者は法律で要求される場合を除き、いかなる条件もなしに、
あらゆる目的でこの作品を使用する権利を誰にでも付与します。

Features / 機能:
- Equirectangular 360° image support / エクイレクタングラー360度画像対応
- High-quality geometric correction / 高品質幾何学的歪み補正
- Drag & drop image loading / ドラッグ&ドロップ画像読み込み
- Touch and mouse controls / タッチ・マウス操作対応
- Fully client-side processing / 完全クライアントサイド処理

Created: 2025 Junji Ikeda
-->


<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Panorama Viewer</title>
    <meta name="description" content="360度パノラマ画像ビューアー - エクイレクタングラー画像対応、幾何学的歪み補正済み">
    <meta name="keywords" content="360度, パノラマ, ビューアー, エクイレクタングラー, VR, 360 degree, panorama, viewer, equirectangular">
    <meta name="author" content="Released under CC0 1.0 Universal">
    
    <style>
        /**
         * 360° Panorama Viewer Styles
         * CC0 1.0 Universal - Public Domain
         */
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 16px;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.4;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .hidden {
            display: none;
        }
        
        #fileControls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
        }
        
        #fileInput {
            display: none;
        }
        
        #selectButton {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
        }
        
        #selectButton:hover {
            background: linear-gradient(135deg, #0056b3, #004085);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.4);
        }
        
        #selectButton:active {
            transform: translateY(0);
        }
        
        /* ドラッグ&ドロップエリア */
        #dropZone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            background: rgba(0, 123, 255, 0.1);
            border: 3px dashed rgba(0, 123, 255, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        #dropZone.show {
            display: flex;
        }
        
        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            
            
            #selectButton {
                font-size: 12px;
                padding: 10px 16px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">画像を読み込み中...</div>
        
        <div id="info">
            <strong>360° Panorama Viewer</strong><br>
        </div>
                
        <div id="fileControls">
            <input type="file" id="fileInput" accept="image/*" />
            <button id="selectButton">360°写真を選択</button>
        </div>
        
        <div id="dropZone">
            <div>
                <div>📷</div>
                <div>360°写真をここにドロップ</div>
            </div>
        </div>
    </div>

    <!-- Three.js ライブラリ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        /**
         * 360° Panorama Viewer JavaScript
         * CC0 1.0 Universal - Public Domain
         * 
         * This script creates a 360-degree panorama viewer with:
         * - Equirectangular image support
         * - High-quality geometric correction
         * - Touch and mouse controls
         * - Drag & drop functionality
         */
        
        // グローバル変数
        let scene, camera, renderer;
        let sphere;
        let isMouseDown = false;
        let previousMouseX = 0, previousMouseY = 0;
        let phi = 0, theta = Math.PI / 2; // 球面座標
        let radius = 1;
        
        // タッチ操作用変数
        let isTouching = false;
        let isPinching = false;
        let previousTouchX = 0, previousTouchY = 0;
        let previousPinchDistance = 0;

        // 高品質設定 (256セグメント × 128リング)
        const SPHERE_SEGMENTS = 256;
        const SPHERE_RINGS = 128;
        const SPHERE_RADIUS = 500;
        
        /**
         * アプリケーション初期化
         */
        function init() {
            // Three.jsシーン設定
            scene = new THREE.Scene();
            
            // カメラ設定
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 0, 0);
            
            // レンダラー設定（高品質）
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            // デフォルト画像を試行（オプション）
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'sample360.jpg', // デフォルト画像（存在しない場合はデモ画像）
                function(texture) {
                    setupTexture(texture);
                    createEquirectangularSphere(texture);
                    document.getElementById('loading').classList.add('hidden');
                    animate();
                },
                function(progress) {
                    console.log('Loading progress: ' + (progress.loaded / progress.total * 100) + '%');
                },
                function(error) {
                    console.log('デフォルト画像が見つかりません。デモ画像を表示します。');
                    createDemoSphere();
                    animate();
                }
            );
            
            // イベントリスナー設定
            setupEventListeners();
            setupFileControls();
            setupDragAndDrop();
            updateCamera();
        }

        /**
         * テクスチャ設定の最適化
         */
        function setupTexture(texture) {
            // 高品質フィルタリング
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            // 異方性フィルタリング（対応デバイスのみ）
            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.anisotropy = Math.min(16, maxAnisotropy);
            
            // ラッピング設定
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            
            texture.needsUpdate = true;
            return texture;
        }
        
        /**
         * エクイレクタングラー用球面メッシュ作成
         */
        function createEquirectangularSphere(texture) {
            // 既存の球体を削除（メモリリーク防止）
            if (sphere) {
                scene.remove(sphere);
                if (sphere.geometry) sphere.geometry.dispose();
                if (sphere.material && sphere.material.map) sphere.material.map.dispose();
                if (sphere.material) sphere.material.dispose();
            }

            // 高品質ジオメトリ作成
            const geometry = createEquirectangularGeometry(
                SPHERE_RADIUS, 
                SPHERE_SEGMENTS, 
                SPHERE_RINGS
            );
            
            // マテリアル作成
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.BackSide // 内側から見るため
            });
            
            // メッシュ作成とシーンに追加
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
        }

        /**
         * エクイレクタングラー画像用の最適化された球面ジオメトリ
         * 極点での幾何学的歪みを最小化
         */
        function createEquirectangularGeometry(radius, widthSegments, heightSegments) {
            const geometry = new THREE.BufferGeometry();
            
            const indices = [];
            const vertices = [];
            const normals = [];
            const uvs = [];
            
            // 頂点とUV座標の生成
            for (let iy = 0; iy <= heightSegments; iy++) {
                const v = iy / heightSegments;
                const phi = v * Math.PI; // 緯度角: 0(北極) → π(南極)
                
                for (let ix = 0; ix <= widthSegments; ix++) {
                    const u = ix / widthSegments;
                    const theta = u * Math.PI * 2; // 経度角: 0 → 2π
                    
                    // 球面座標から直交座標への変換
                    const x = -radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.cos(phi);
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    
                    vertices.push(x, y, z);
                    
                    // 法線ベクトル
                    const nx = -Math.sin(phi) * Math.cos(theta);
                    const ny = Math.cos(phi);
                    const nz = Math.sin(phi) * Math.sin(theta);
                    normals.push(nx, ny, nz);
                    
                    // UV座標（反転済み）
                    uvs.push(1 - u, 1 - v);
                }
            }
            
            // インデックス生成（極点での三角形退化防止）
            for (let iy = 0; iy < heightSegments; iy++) {
                for (let ix = 0; ix < widthSegments; ix++) {
                    const a = iy * (widthSegments + 1) + ix;
                    const b = a + widthSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    if (iy === 0) {
                        // 北極点: 上の三角形のみ
                        indices.push(a, b, d);
                    } else if (iy === heightSegments - 1) {
                        // 南極点: 下の三角形のみ
                        indices.push(a, b, c);
                    } else {
                        // 通常の四角形を2つの三角形に分割
                        indices.push(a, b, c);
                        indices.push(b, d, c);
                    }
                }
            }
            
            // ジオメトリ属性設定
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            
            return geometry;
        }
        
        /**
         * デモ用球面作成（360度画像がない場合）
         */
        function createDemoSphere() {
            const canvas = document.createElement('canvas');
            canvas.width = 4096;  // 4K解像度
            canvas.height = 2048; // 2:1 エクイレクタングラー比率
            const context = canvas.getContext('2d');
            
            // グラデーション背景
            const gradient = context.createLinearGradient(0, 0, 0, 2048);
            gradient.addColorStop(0, '#87CEEB');    // 天頂: 空色
            gradient.addColorStop(0.5, '#32CD32');  // 赤道: 緑
            gradient.addColorStop(1, '#8B4513');    // 天底: 茶色
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 4096, 2048);
            
            // 緯度・経度グリッド描画
            context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            context.lineWidth = 3;
            
            // 経度線（15度間隔）
            for (let i = 0; i <= 24; i++) {
                const x = (4096 / 24) * i;
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, 2048);
                context.stroke();
            }
            
            // 緯度線（15度間隔）
            for (let i = 0; i <= 12; i++) {
                const y = (2048 / 12) * i;
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(4096, y);
                context.stroke();
            }
            
            // 主要線を強調
            context.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            context.lineWidth = 5;
            
            // 赤道線
            context.beginPath();
            context.moveTo(0, 1024);
            context.lineTo(4096, 1024);
            context.stroke();
            
            // 本初子午線
            context.beginPath();
            context.moveTo(2048, 0);
            context.lineTo(2048, 2048);
            context.stroke();
            
            // 説明テキスト
            context.fillStyle = 'white';
            context.font = 'bold 72px Arial';
            context.textAlign = 'center';
            context.shadowColor = 'black';
            context.shadowBlur = 8;
            
            context.fillText('⬆️', 2048, 630);
            context.fillText('アルバムから', 2048, 896);
            context.fillText('⬅️　　　360写真を　　　➡️', 2048, 1024);
            context.fillText('選択してください', 2048, 1152);
            context.fillText('⬇️', 2048, 1406);
            
            const texture = new THREE.CanvasTexture(canvas);
            setupTexture(texture);
            createEquirectangularSphere(texture);
            document.getElementById('loading').classList.add('hidden');
        }
        
        /**
         * イベントリスナー設定
         */
        function setupEventListeners() {
            const canvas = renderer.domElement;
            
            // マウスイベント
            canvas.addEventListener('mousedown', onMouseDown, { passive: false });
            canvas.addEventListener('mousemove', onMouseMove, { passive: false });
            canvas.addEventListener('mouseup', onMouseUp, { passive: false });
            canvas.addEventListener('wheel', onMouseWheel, { passive: false });
            
            // タッチイベント
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd, { passive: false });
            
            // ウィンドウリサイズ
            window.addEventListener('resize', onWindowResize, false);
            
            // コンテキストメニュー無効化
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            }, false);
        }
        
        // マウスイベントハンドラー
        function onMouseDown(event) {
            isMouseDown = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
            event.preventDefault();
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;
            
            phi -= deltaX * 0.002;
            theta -= deltaY * 0.002;
            
            // 天頂・天底の制限
            theta = Math.max(0.01, Math.min(Math.PI - 0.01, theta));
            
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
            
            updateCamera();
            event.preventDefault();
        }
        
        function onMouseUp(event) {
            isMouseDown = false;
            event.preventDefault();
        }
        
        function onMouseWheel(event) {
            const fov = camera.fov + event.deltaY * 0.05;
            camera.fov = Math.max(10, Math.min(120, fov));
            camera.updateProjectionMatrix();
            event.preventDefault();
        }
        
        // タッチイベントハンドラー
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                // シングルタッチ: 回転
                isTouching = true;
                isPinching = false;
                previousTouchX = event.touches[0].clientX;
                previousTouchY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                // ピンチ: ズーム
                isTouching = false;
                isPinching = true;
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                previousPinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
            event.preventDefault();
        }
        
        function onTouchMove(event) {
            if (isTouching && event.touches.length === 1) {
                // 回転処理
                const deltaX = event.touches[0].clientX - previousTouchX;
                const deltaY = event.touches[0].clientY - previousTouchY;
                
                phi -= deltaX * 0.002;
                theta -= deltaY * 0.002;
                
                theta = Math.max(0.01, Math.min(Math.PI - 0.01, theta));
                
                previousTouchX = event.touches[0].clientX;
                previousTouchY = event.touches[0].clientY;
                
                updateCamera();
            } else if (isPinching && event.touches.length === 2) {
                // ズーム処理
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);
                
                const pinchDelta = currentPinchDistance - previousPinchDistance;
                const fov = camera.fov - pinchDelta * 0.2;
                camera.fov = Math.max(20, Math.min(135, fov));
                camera.updateProjectionMatrix();
                
                previousPinchDistance = currentPinchDistance;
            }
            event.preventDefault();
        }
        
        function onTouchEnd(event) {
            isTouching = false;
            isPinching = false;
            event.preventDefault();
        }
        
        /**
         * カメラ位置更新
         */
        function updateCamera() {
            const x = radius * Math.sin(theta) * Math.cos(phi);
            const y = radius * Math.cos(theta);
            const z = radius * Math.sin(theta) * Math.sin(phi);
            
            camera.position.set(0, 0, 0);
            camera.lookAt(x, y, z);
        }
        
        /**
         * ウィンドウリサイズ処理
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        /**
         * アニメーションループ
         */
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        /**
         * ファイル選択コントロール設定
         */
        function setupFileControls() {
            const fileInput = document.getElementById('fileInput');
            const selectButton = document.getElementById('selectButton');
            
            selectButton.addEventListener('click', function() {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    loadImageFile(file);
                }
            });
        }
        
        /**
         * ドラッグ&ドロップ機能設定
         */
        function setupDragAndDrop() {
            const container = document.getElementById('container');
            const dropZone = document.getElementById('dropZone');
            let dragCounter = 0;
            
            // ドラッグエンター
            container.addEventListener('dragenter', function(e) {
                e.preventDefault();
                dragCounter++;
                dropZone.classList.add('show');
            });
            
            // ドラッグリーブ
            container.addEventListener('dragleave', function(e) {
                e.preventDefault();
                dragCounter--;
                if (dragCounter === 0) {
                    dropZone.classList.remove('show');
                }
            });
            
            // ドラッグオーバー
            container.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            // ドロップ
            container.addEventListener('drop', function(e) {
                e.preventDefault();
                dragCounter = 0;
                dropZone.classList.remove('show');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    loadImageFile(files[0]);
                }
            });
        }
        
        /**
         * 画像ファイル読み込み
         */
        function loadImageFile(file) {
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('loading').innerHTML = '画像を読み込み中...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    e.target.result,
                    function(texture) {
                        setupTexture(texture);
                        createEquirectangularSphere(texture);
                        document.getElementById('loading').classList.add('hidden');
                        
                        // カメラをリセット
                        phi = 0;
                        theta = Math.PI / 2;
                        camera.fov = 75;
                        camera.updateProjectionMatrix();
                        updateCamera();
                    },
                    undefined,
                    function(error) {
                        console.error('画像の読み込みに失敗しました:', error);
                        document.getElementById('loading').innerHTML = '画像の読み込みに失敗しました';
                        setTimeout(() => {
                            document.getElementById('loading').classList.add('hidden');
                        }, 2000);
                    }
                );
            };
            
            reader.onerror = function() {
                console.error('ファイルの読み込みに失敗しました');
                document.getElementById('loading').innerHTML = 'ファイルの読み込みに失敗しました';
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 2000);
            };
            
            reader.readAsDataURL(file);
        }
        
        // アプリケーション開始
        init();
    </script>
</body>
</html>