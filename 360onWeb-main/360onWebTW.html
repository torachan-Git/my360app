<!--
/**
 * 360 Image DEEP HACK 360onWeb - Enhanced with Exponential Effect + Image Rotate (2D)
 * 
 * @description 360ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ç·¨é›†ã™ã‚‹Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæŒ‡æ•°é–¢æ•°åŠ¹æœä»˜ã + ç”»åƒã®2Då›è»¢ + ç·¨é›†ä½™ç™½10%ï¼‰
 * @author ã„ã‘ã ã˜ã‚…ã‚“ã˜ (enhanced by Claude, updated by ChatGPT)
 * @version 1k edit1k save4k Clear D&D XYmove + Exponential Effect + ImageRotate2D (Order: Effects â†’ Shift â†’ 2D Rotate)
 * @date 20250812 
 * @license Public Domain - å†é…å¸ƒã€æ”¹å¤‰è‡ªç”±ã€ä¸€åˆ‡ã®åˆ¶é™ãªã—
 * @disclaimer 
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
 *   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DAMAGES ARISING FROM THE USE OF THIS SOFTWARE.
 *   ã“ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯ç„¡ä¿è¨¼ã§æä¾›ã•ã‚Œã€ä½œè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
 *   - ãƒ¡ãƒ¢ãƒªä¸è¶³ã«ã‚ˆã‚‹ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™
 *   - å‡¦ç†çµæœã®å“è³ªã¯ä¿è¨¼ã•ã‚Œã¾ã›ã‚“
 *   - é‡è¦ãªãƒ‡ãƒ¼ã‚¿ã¯äº‹å‰ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ãã ã•ã„
 *   - æœ¬ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ä½¿ç”¨ã¯è‡ªå·±è²¬ä»»ã§ãŠé¡˜ã„ã—ã¾ã™
 */
-->

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360onWeb</title>
    <style>
    
        :root {
                /* å…¨ä½“ã®èƒŒæ™¯è‰²ã®æŒ‡å®š */
            --bg-gradient-start: #1e3c72;   /* é’#1e3c72 ç´«#3d1a78 æ©™#cc5500 ç·‘#2d5016*/
            --bg-gradient-end: #2a5298;     /* é’#2a5298 ç´«#7209b7 æ©™#ff8c42 ç·‘#4a7c59*/
            
                /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®æŒ‡å®š */    
            --slider-grdnt-start: #4CAF50;  /* #4CAF50 */
            --slider-grdnt-end: #2196F3;    /* #2196F3 */
            
                /* ä¸Šéƒ¨ã‚¨ãƒªã‚¢ã®æŒ‡å®š */    
            --upload-area-border--: 3px dashed #4CAF50;     /* 3px dashed #4CAF50 */
            --upload-area-bg--: rgba(255,255,255,0.1);      /*  rgba(255,255,255,0.15) */
            --upload-hover-border--: #45a049;               /* #45a049 */
            --upload-hover-bg--: rgba(255,255,255,0.15);    /*  rgba(255,255,255,0.15) */
            --upload-dragover-border--: #2196F3;            /* #2196F3 */
            --upload-dragover-bg--: rgba(33,150,243,0.2);   /* rgba(33,150,243,0.2) */
            
                 /* ä¸Šéƒ¨èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³ã®æŒ‡å®š */
            --upload-btn--: #4CAF50;        /* #4CAF50 */
            --upload-btn-hover--: #45a049;  /* #45a049 */
            
            --random-btn--: #FF6B6B;
            
                 /* ä¸‹éƒ¨ä¿å­˜ãƒ»å…±æœ‰ãƒœã‚¿ãƒ³ã®æŒ‡å®š */    
            --download-btn-bg--: linear-gradient(45deg, #667eea, #764ba2);  /* linear-gradient(45deg, #667eea, #764ba2) */
            --download-btn-hover--: rgba(0,0,0,0.3);                        /* rgba(0,0,0,0.3) */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));/* styleç›´å¾Œ :rootã§æŒ‡å®š */
            color: white;
            min-height: 100vh;
        }
    
        .container {
            max-width: 1524px;// max 1200 20250808
            margin: 0 auto;
        }
    
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: 24px;
        }
            /* for guidelines */
        .upload-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: nowrap;
        }
    
        /* for guidelines 20250811+ */
        .app-title {
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        
        .upload-area {
            border: var(--upload-area-border--);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            background: var(--upload-area-bg--);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
    
        .upload-area:hover {
            border-color: var(--upload-hover-border--);
            background: var(--upload-hover-bg--);        }
    
        .upload-area.dragover {
            border-color: var(--upload-dragover-border--);
            background: var(--upload-dragover-bg--);
        }
    
        input[type="file"] {
            display: none;
        }
    
        .upload-btn {
            background: var(--upload-btn--);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
            white-space: nowrap;/* for guidelines 20250811+ */
        }
    
        .upload-btn:hover {
            background: var(--upload-btn-hover--);
        }
    
        .random-btn {
      /* å¶ç„¶ã‚’æ¥½ã—ã‚‚ã†ï¼ */
      width: 5%;
      background: transparent; /* èƒŒæ™¯ã‚’é€æ˜ã« */
      color: white; /* çµµæ–‡å­—ã®è‰²ï¼ˆå¿…è¦ã«å¿œã˜ã¦å¤‰æ›´ï¼‰ */
      padding: 12px 24px;
      border: none; /* æ ç·šãªã— */
      border-radius: 5px;
      cursor: pointer;
      font-size: 32px; /* çµµæ–‡å­—ã®ã‚µã‚¤ã‚º */
      transition: all 0.3s ease;
      display: flex; /* çµµæ–‡å­—ã‚’ä¸­å¤®ã«é…ç½® */
      justify-content: center;
      align-items: center;
    }
    .random-btn:hover {
      transform: scale(1.1); /* ãƒ›ãƒãƒ¼æ™‚ã«å°‘ã—æ‹¡å¤§ */
    }
    
        .main-content { /* èµ·å‹•æ™‚ã¯ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç¾¤ã‚’è¡¨ç¤ºã—ãªã„ï¼ */
            display: none;
        }
    
        .editor-container { /* ç·¨é›†è¡¨ç¤ºé ˜åŸŸã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç¾¤ã¨ã®é–“éš” */
            display: flex; /* å¾ŒåŠã‚³ãƒ¼ãƒ‰ã§ç¸¦å‘ãç”¨CSSã§ä¸Šæ›¸ãæœ‰ã‚Šã€ã‚ˆã£ã¦æ¨ªå‘ãç”¨ */
            gap: 30px;
            align-items: flex-start;
        }
    
        .canvas-container {
            flex: 1;
            text-align: center;
        }
    
        .canvas-wrapper {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
    
        canvas {
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 100%;
            height: auto;
            touch-action: none;
            cursor: grab;
        }
    
        canvas:active {
            cursor: grabbing;
        }
    
        .controls {
            width: 300px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
    
        .control-group {
            margin-bottom: 18px;
        }
    
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
            color: #f0f0f0;
        }
    
        .label-text {
            text-align: left;
        }
    
        .value-display {
            font-size: 14px;
            color: #ddd;
            text-align: right;
            min-width: 70px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
    
        .value-display:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }
    
        .value-input {
            font-size: 14px;
            color: white;
            text-align: right;
            min-width: 70px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #4CAF50;
            border-radius: 4px;
            padding: 2px 6px;
            outline: none;
        }
    
        .slider-container {
            position: relative;
        }
    
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--slider-grdnt-start), var(--slider-grdnt-end));
            outline: none;
            -webkit-appearance: none;
        }
    
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    
        .download-btn {
            width: 100%;
            background: var(--download-btn-bg--);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
    
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--download-btn-hover--);
        }
    
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
    
        .loading-content {
            text-align: center;
            color: white;
            font-size: 18px;
        }
    
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
    
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    
        .touch-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }
        
 /* å›è»¢ãƒœã‚¿ãƒ³ã®CSS 20250814++ */       
.guideline-rotate-btn {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.3);
    border: none;
    border-radius: 50%;
    color: white;
    font-size: 18px;
    cursor: pointer;
    z-index: 15;
    transition: background 0.3s;
}

.guideline-rotate-btn:hover {
    background: rgba(255, 255, 255, 0.5);
}
    
        /* ç¸¦å‘ãï¼ˆãƒãƒ¼ãƒˆãƒ¬ãƒ¼ãƒˆï¼‰ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        @media screen and (orientation: portrait) {
            .container { /* for main window */
                display: flex;
                flex-direction: column;
                width: 100%;
                margin: 0 auto;
            }
            
            .upload-area {
                width: 100% !important;
                margin-bottom: 20px;
                box-sizing: border-box;
            }
            
            .editor-container {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            
            .canvas-container {
                width: 100% !important;
                box-sizing: border-box;
            }
            
            .controls {
                width: 100% !important;
                margin: 0;
                box-sizing: border-box;
            }
            
            .canvas-wrapper {
                padding: 15px;
                box-sizing: border-box;
            }
            
            .controls {
                padding: 20px;
                box-sizing: border-box;
            }
        }
    
        /* æ¨ªå‘ãï¼ˆãƒ©ãƒ³ãƒ‰ã‚¹ã‚±ãƒ¼ãƒ—ï¼‰ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        @media screen and (orientation: landscape) {
            .container { /* for main window */
                display: flex;
                flex-direction: column;
            }
            
            .upload-area {
                width: 96%;// 100% 20250808
                margin-bottom: 20px;
                order: -1;
            }
            
            .editor-container {
                display: flex;
                flex-direction: row;
                gap: 20px;
            }
            
            .canvas-container {
                flex: 1;
                width: 50%;
            }
            
            .controls {
                flex: 1;
                width: 50%;
                margin: 0;
            }
        }
    
        /* å°ã•ãªç”»é¢ã§ã®èª¿æ•´ */
        @media (max-width: 768px) {
            .editor-container {
                gap: 10px;
            }
            
            .canvas-wrapper {
                padding: 15px;
            }
            
            .controls {
                padding: 20px;
            }
        }
        
        
        
        /* æ§‹å›³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« 20250811+ */
        .guideline-menu {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .guideline-menu label {
            color: white;
            font-size: 14px;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .guideline-menu select {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .guideline-menu select:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .guideline-menu select option {
            background: #333;
            color: white;
        }
                
        .guideline-select {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
            min-width: 100px;
            flex-shrink: 0;
        }
        
        .guideline-select:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .guideline-select option {
            background: #333;
            color: white;
        }
            
            

    </style>
</head>
<body>
    <div class="container"> <!-- main window- -->
        <!-- â‘  ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒªã‚¢ -->
        <div class="upload-area" id="uploadArea">  <!-- drag & drop area--- -->
            <div class="upload-header">
                <!-- <span class="app-title">360onWeb</span> -->
                <button class="upload-btn" onclick="resetControlsAndSelectFile()">
                    ğŸ–¼ï¸+360onWeb
                </button>
                <select id="guidelineSelect" class="guideline-select">
                    <option value="none">ã‚¬ã‚¤ãƒ‰ãªã—(1ã€œ16)</option>
                    <option value="line01"> 1.åŒå¿ƒå††</option>
                    <option value="line02"> 2.ä¸‰é‡å††</option>
                    <option value="line03"> 3.å††åˆ†å‰²</option>
                    <option value="line04"> 4.ã—ã¼ã‚Š</option>
                    <option value="line05"> 5.æ¸¦å·»ã</option>
                    <option value="line06"> 6.ä¸‰åˆ†å‰²</option>
                    <option value="line07"> 7.å››åˆ†å‰²</option>
                    <option value="line08"> 8.æ”¾å°„åˆ†å‰²</option>
                    <option value="line09"> 9.æ–œã‚åˆ†å‰²</option>
                    <option value="line10">10.é è¿‘æ–œã‚</option>
                    <option value="line11">11.é è¿‘æ°´å¹³</option>
                    <option value="line12">12.ãƒ•ã‚£ãƒœãƒŠãƒƒãƒ</option>
                    <option value="line13">13.Så­—</option>
                    <option value="line14">14.Uå­—</option>
                    <option value="line15">15.äºŒã¤çª“</option>
                    <option value="line16">16.é›»å½±ã‚¯ãƒ­ã‚¹ã‚²ãƒ¼ã‚¸</option>
                </select>
                
                <button class="random-btn" id="randomBtn">ğŸ¤¯</button>
            </div>
            <input type="file" id="fileInput" accept="image/*">
        </div>  <!-- ---drag & drop area -->

        <div class="main-content" id="mainContent">  <!-- controlls èµ·å‹•æ™‚éè¡¨ç¤º--- -->
            <div class="editor-container"> <!-- ç¸¦é•·ãƒ»æ¨ªé•·ãƒ»å°ã‚µã‚¤ã‚ºã®è¨­å®š--- -->
                <div class="canvas-container"> <!-- è¡¨ç¤ºã¨ã‚¿ãƒƒãƒ--- -->
                    <div class="canvas-wrapper">
                        <canvas id="canvas" width="720" height="720">ã€€<!-- 720 x 720 è¡¨ç¤ºã‚µã‚¤ã‚º -->
                    
                        </canvas>
                        
                        
  <!-- ã“ã“ã«å›è»¢ãƒœã‚¿ãƒ³ã‚’è¿½åŠ  20250814++ -->
    <button id="guidelineRotateBtn" class="guideline-rotate-btn" style="display: none;">
        ğŸ”„
    </button>
                                             
                        <div class="touch-indicator" id="touchIndicator">
                        Move Center</div>
                    </div>
                </div> <!-- ---è¡¨ç¤ºã¨ã‚¿ãƒƒãƒ -->
                <div class="controls">  <!-- ??? inner --- -->
                    <div class="control-group"> <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 1 -->
                        <div class="control-label">
                            <span class="label-text">ğŸ” Zoom æ‹¡å¤§ç¸®å°</span>
                            <input type="text" class="value-input" id="scaleInput" value="1.5" style="display: none;">
                            <span class="value-display" id="scaleValue">1.50</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="scaleSlider" min="0.1" max="2.9" step="0.1" value="1.5">
                        </div>
                    </div>
                    <div class="control-group"> <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 2 -->
                        <div class="control-label">
                            <span class="label-text">âš¡ V-Flex ç¸¦-ä¼¸ç¸®</span>
                            <input type="text" class="value-input" id="exponentialInput" value="0.0" style="display: none;">
                            <span class="value-display" id="exponentialValue">0.00</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="exponentialSlider" min="-1.0" max="1.0" step="0.01" value="0">
                        </div>
                    </div>
                    
                    
                    

                    
                    
                    
                    <div class="control-group"> <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 3 -->
                        <div class="control-label">
                            <span class="label-text">â†•ï¸ Up Down ä¸Šä¸‹</span>
                            <input type="text" class="value-input" id="pitchInput" value="0Â°" style="display: none;">
                            <span class="value-display" id="pitchValue">0.00Â°</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="pitchSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                    <div class="control-group"> <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 4 -->
                        <div class="control-label">
                            <span class="label-text">â†”ï¸ Left Right å·¦å³</span>
                            <input type="text" class="value-input" id="rollInput" value="0Â°" style="display: none;">
                            <span class="value-display" id="rollValue">0.00Â°</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="rollSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                    <div class="control-group"> <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 5 -->
                        <div class="control-label">
                            <span class="label-text">ğŸ”„ Rotate å›è»¢</span>
                            <input type="text" class="value-input" id="yawInput" value="0Â°" style="display: none;">
                            <span class="value-display" id="yawValue">0.00Â°</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="yawSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                    
                    
                    
                    
                    
                    
                    <!-- æ—¢å­˜ã®V-Flexã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å¾Œã«è¿½åŠ  20250817+ -->
<div class="control-group"> <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 3.5 æ¸¦å·»ããƒ•ã‚£ãƒ«ã‚¿ãƒ¼ -->
    <div class="control-label">
        <span class="label-text">ğŸŒ€ Twister ç«œå·»</span>
        <input type="text" class="value-input" id="swirlInput" value="0.0" style="display: none;">
        <span class="value-display" id="swirlValue">0.00</span>
    </div>
    <div class="slider-container">
        <input type="range" id="swirlSlider" min="-2.0" max="2.0" step="0.1" value="0">
    </div>
</div>                    
                    
                    
                    
                    
                    <div class="control-group"> <!-- â˜… ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 6: 2Dç”»åƒå›è»¢ï¼ˆæœ€å¾Œæ®µï¼‰ -->
                        <div class="control-label">
                            <span class="label-text">XY-rotate</span>
                            <input type="text" class="value-input" id="imgRotateInput" value="0Â°" style="display: none;">
                            <span class="value-display" id="imgRotateValue">0.00Â°</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="imgRotateSlider" min="-180" max="180" step="1" value="0">
                        </div>
                    </div>
                     <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 7 ä½†ã—PCï¼ˆX/Yã‚·ãƒ•ãƒˆï¼š2Dã®ç›´å‰æ®µï¼‰ -->
                    <div class="control-group" id="centerXGroup" style="display: none;">
                        <div class="control-label">
                            <span class="label-text"> X-shift</span>
                            <input type="text" class="value-input" id="centerXInput" value="0.00" style="display: none;">
                            <span class="value-display" id="centerXValue">0.00</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="centerXSlider" min="-1" max="1" step="0.01" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                    <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ 8 ä½†ã—PC -->
                    <div class="control-group" id="centerYGroup" style="display: none;">
                        <div class="control-label">
                            <span class="label-text"> Y-shift</span>
                            <input type="text" class="value-input" id="centerYInput" value="0.00" style="display: none;">
                            <span class="value-display" id="centerYValue">0.00</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="centerYSlider" min="-1" max="1" step="0.01" value="0" style="transform: scaleX(-1);">
                        </div>
                    </div>
                
                    <!-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ 1 -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;"> 
                        <label for="editModeSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        ğŸš Edit type
                        </label>
                        <select id="editModeSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="little_planet" style="background: #333; color: white;">Little Planet</option>
                            <option value="rabbit_hole" style="background: #333; color: white;">Rabbit Hole</option>
                        </select>
                    </div>
                    <!-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ 2 -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;"> 
                        <label for="formatSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        ğŸ¨ Format type
                        </label>
                        <select id="formatSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="jpeg" style="background: #333; color: white;">JPG 80%</option>
                            <option value="png" style="background: #333; color: white;">PNG</option>
                        </select>
                    </div>
                     <!-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ 3 -->
                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <label for="resolutionSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        ğŸ“ Pixel size
                        </label>
                        <select id="resolutionSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="512" style="background: #333; color: white;">512Ã—512 (Preview)</option>
                            <option value="2048" style="background: #333; color: white;">2048Ã—2048 (2K)</option>
                            <option value="4096" style="background: #333; color: white;">4096Ã—4096 (4K)</option>
                        </select>
                    </div>
                    
                    <button class="download-btn" id="downloadBtn">ğŸ“‚ Download</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loadingText">Processing image...</div>
        </div>
    </div>

    <script>
        let originalImage = null;
        let workingImage = null;  // ç·¨é›†ç”¨ 1024x512
        let downloadImage = null; // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ 4096x2048
        let isLittlePlanet = true;

        // ä¸­å¿ƒä½ç½®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆX/Yã‚·ãƒ•ãƒˆï¼š2Då›è»¢ã®ç›´å‰æ®µãƒ»è¦‹ãŸç›®é †ã§ã¯ä¸­é–“æ®µï¼‰
        let centerOffsetX = 0;
        let centerOffsetY = 0;
                
                // æ§‹å›³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³é–¢é€£ 20250811+
        let guidelineImages = {};
        const guidelineTypes = ['line01', 'line02', 'line03', 'line04', 'line05', 'line06', 'line07', 'line08', 'line09', 'line10', 'line11', 'line12', 'line13', 'line14', 'line15', 'line16'];
        
        
        
        // æ—¢å­˜ã®å¤‰æ•°ç¾¤ã¨ä¸€ç·’ã«å®£è¨€ 20250814++
let guidelineRotation = 0; // ã“ã“ã«è¿½åŠ 
                
        window.addEventListener('load', function() {
                loadSampleImage();        
                loadGuidelineImages();// 20250811+
                // window.addEventListener('load'å†…ã«è¿½åŠ 
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¿½åŠ ï¼ˆDOMè¦ç´ å–å¾—å¾Œï¼‰// 20250811+
                const guidelineSelect = document.getElementById('guidelineSelect');
                guidelineSelect.addEventListener('change', function() {
                    
    guidelineRotation = 0; // ã“ã®è¡Œã‚’è¿½åŠ  20250814++
                    
                render(); // for draw guideline
                
            });
            
// ã“ã“ã«æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ ã€€20250814++
document.getElementById('guidelineRotateBtn').addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation(); // canvasæ“ä½œã¨ã®å¹²æ¸‰ã‚’é˜²ã
    
    guidelineRotation = (guidelineRotation + 45) % 360; // test 45 degree 20280815
    render(); // å†æç”»
});
            
            
            
            // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
//            window.addEventListener('resize', function() {
//                setTimeout(updateGuidelineSize, 100);
//            });
            
//            window.addEventListener('orientationchange', function() {
//                setTimeout(updateGuidelineSize, 300);
//            });
                        
            
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            if (!isTouchDevice) {
                document.getElementById('centerXGroup').style.display = 'block';
                document.getElementById('centerYGroup').style.display = 'block';
            }
        });

        function showLoading(text) {
            const overlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = text;
            overlay.style.display = 'flex';
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = 'none';
        }

        function loadSampleImage() {
            if (location.protocol === 'file:') {
                console.log('Local environment detected. Sample image loading skipped.');
                return;
            }
            const sampleImage = new Image();
            sampleImage.onload = function() {
                originalImage = sampleImage;
                createWorkingImages();
            };
            sampleImage.onerror = function() {
                console.log('sample4k.jpg is not available. select 360 image');
            };
            sampleImage.src = './sample4k.jpg';
        }
        
        // æ§‹å›³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ç”»åƒã®èª­ã¿è¾¼ã¿ 20250811+
        function loadGuidelineImages() {
            if (location.protocol === 'file:') {
                console.log('Local environment detected. Guideline images loading skipped.');
                return;
            }
        
            guidelineTypes.forEach(type => {
                const img = new Image();
                img.onload = function() {
                    guidelineImages[type] = img;
                    console.log(`Guideline image loaded: ${type}`);
                };
                img.onerror = function() {
                    console.log(`Guideline image not found: lines/${type}.png`);
                };
                img.src = `./lines/${type}.png`;
            });
        }

        function resetControlsAndSelectFile() {
            resetControls();
            document.getElementById('fileInput').click();
        }
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const mainContent = document.getElementById('mainContent');
        const touchIndicator = document.getElementById('touchIndicator');

        const scaleSlider = document.getElementById('scaleSlider');
        const exponentialSlider = document.getElementById('exponentialSlider');
        const pitchSlider = document.getElementById('pitchSlider');
        const rollSlider = document.getElementById('rollSlider');
        const yawSlider = document.getElementById('yawSlider');
        const imgRotateSlider = document.getElementById('imgRotateSlider');
        const editModeSelect = document.getElementById('editModeSelect');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const formatSelect = document.getElementById('formatSelect');

        const scaleValue = document.getElementById('scaleValue');
        const exponentialValue = document.getElementById('exponentialValue');
        const pitchValue = document.getElementById('pitchValue');
        const rollValue = document.getElementById('rollValue');
        const yawValue = document.getElementById('yawValue');
        const imgRotateValue = document.getElementById('imgRotateValue');
        const centerXValue = document.getElementById('centerXValue');
        const centerYValue = document.getElementById('centerYValue');

        const scaleInput = document.getElementById('scaleInput');
        const exponentialInput = document.getElementById('exponentialInput');
        const pitchInput = document.getElementById('pitchInput');
        const rollInput = document.getElementById('rollInput');
        const yawInput = document.getElementById('yawInput');
        const imgRotateInput = document.getElementById('imgRotateInput');
        const centerXInput = document.getElementById('centerXInput');
        const centerYInput = document.getElementById('centerYInput');

        const centerXSlider = document.getElementById('centerXSlider');
        const centerYSlider = document.getElementById('centerYSlider');
        
        
        
 // æ—¢å­˜ã®å¤‰æ•°å®£è¨€ã®å¾Œã«è¿½åŠ  20250817++
const swirlSlider = document.getElementById('swirlSlider');
const swirlValue = document.getElementById('swirlValue');
const swirlInput = document.getElementById('swirlInput');

// tempVariables ã«è¿½åŠ 
let tempSwirl = parseFloat(swirlSlider.value) || 0;       
        
        
        

        let isDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let lastPinchDistance = 0;
        let isPinching = false;
        let isMovingCenter = false;
        let tempScale = parseFloat(scaleSlider.value) || 1.5;
        let tempExponential = parseFloat(exponentialSlider.value);
        let tempPitch = parseFloat(pitchSlider.value);
        let tempRoll = parseFloat(rollSlider.value);
        let tempYaw = parseFloat(yawSlider.value);
        let tempImgRotate = parseFloat(imgRotateSlider.value) || 0;

        fileInput.addEventListener('change', handleFile);
        
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function() {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                resetControls();
                processFile(files[0]);
            }
        });

        function handleFile(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Choose image file!');
                return;
            }

            showLoading('Loading image...');

            const reader = new FileReader();
            reader.onload = function(e) {
                originalImage = new Image();
                originalImage.onload = function() {
                    console.log('Original image loaded: ' + originalImage.width + 'Ã—' + originalImage.height);
                    createWorkingImages();
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createWorkingImages() {
            if (!originalImage) return;

            showLoading('Creating working images...');

            setTimeout(function() {
                const workingCanvas = document.createElement('canvas');
                const workingCtx = workingCanvas.getContext('2d');
                workingCanvas.width = 1024;
                workingCanvas.height = 512;
                
                workingCtx.drawImage(originalImage, 0, 0, 1024, 512);
                
                workingImage = new Image();
                workingImage.onload = function() {
                    console.log('Working image created: ' + workingImage.width + 'Ã—' + workingImage.height);
                    
                    const downloadCanvas = document.createElement('canvas');
                    const downloadCtx = downloadCanvas.getContext('2d');
                    downloadCanvas.width = 4096;
                    downloadCanvas.height = 2048;
                    
                    downloadCtx.drawImage(originalImage, 0, 0, 4096, 2048);
                    
                    downloadImage = new Image();
                    downloadImage.onload = function() {
                        console.log('Download image created: ' + downloadImage.width + 'Ã—' + downloadImage.height);
                        hideLoading();        
                        
                        mainContent.style.display = 'block';
                        render();
                    };
                    downloadImage.src = downloadCanvas.toDataURL();
                };
                workingImage.src = workingCanvas.toDataURL();
            }, 100);
        }

        function resetControls() {
            scaleSlider.value = '1.5';
            exponentialSlider.value = '0';
            pitchSlider.value = '0';
            rollSlider.value = '0';
            yawSlider.value = '0';
            imgRotateSlider.value = '0';
            scaleValue.textContent = '1.50';
            exponentialValue.textContent = '0.00';
            pitchValue.textContent = '0.00Â°';
            rollValue.textContent = '0.00Â°';
            yawValue.textContent = '0.00Â°';
            imgRotateValue.textContent = '0.00Â°';
            scaleInput.value = '1.50';
            exponentialInput.value = '0.00';
            pitchInput.value = '0.00';
            rollInput.value = '0.00';
            yawInput.value = '0.00';
            imgRotateInput.value = '0.00';
            tempScale = 1.5;
            tempExponential = 0;
            tempPitch = 0;
            tempRoll = 0;
            tempYaw = 0;
            tempImgRotate = 0;
            
            centerOffsetX = 0;
            centerOffsetY = 0;
            
                // æ—¢å­˜ã®ãƒªã‚»ãƒƒãƒˆå‡¦ç†ã®å¾Œã«è¿½åŠ  20250817++ twister filter
    swirlSlider.value = '0';
    swirlValue.textContent = '0.00';
    swirlInput.value = '0.00';
    tempSwirl = 0;
            
            if (centerXSlider && centerYSlider) {
                centerXSlider.value = '0';
                centerYSlider.value = '0';
                centerXValue.textContent = '0.00';
                centerYValue.textContent = '0.00';
                centerXInput.value = '0.00';
                centerYInput.value = '0.00';
            }
            
            
guidelineRotation = 0; // è¿½åŠ  20250814++
document.getElementById('guidelineRotateBtn').style.display = 'none'; // è¿½åŠ 
document.getElementById('guidelineSelect').value = 'none';

            
            
            if (workingImage) {
                render();
            }
        }

        scaleSlider.addEventListener('input', function() {
            tempScale = parseFloat(scaleSlider.value);
            scaleValue.textContent = tempScale.toFixed(2);
            render();
        });

        exponentialSlider.addEventListener('input', function() {
            tempExponential = parseFloat(exponentialSlider.value);
            exponentialValue.textContent = tempExponential.toFixed(2);
            render();
        });
        
        
        
        
        // æ—¢å­˜ã®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®å¾Œã«è¿½åŠ  20250817++
swirlSlider.addEventListener('input', function() {
    tempSwirl = parseFloat(swirlSlider.value);
    swirlValue.textContent = tempSwirl.toFixed(2);
    render();
});
        
        
        

        pitchSlider.addEventListener('input', function() {
            tempPitch = parseFloat(pitchSlider.value);
            pitchValue.textContent = tempPitch.toFixed(2) + 'Â°';
            render();
        });

        rollSlider.addEventListener('input', function() {
            tempRoll = parseFloat(rollSlider.value);
            rollValue.textContent = tempRoll.toFixed(2) + 'Â°';
            render();
        });

        yawSlider.addEventListener('input', function() {
            tempYaw = parseFloat(yawSlider.value);
            yawValue.textContent = tempYaw.toFixed(2) + 'Â°';
            render();
        });

        imgRotateSlider.addEventListener('input', function() {
            tempImgRotate = parseFloat(imgRotateSlider.value);
            imgRotateValue.textContent = tempImgRotate.toFixed(2) + 'Â°';
            render();
        });

        if (centerXSlider && centerYSlider) {
            centerXSlider.addEventListener('input', function() {
                centerOffsetX = -parseFloat(centerXSlider.value);
                centerXValue.textContent = parseFloat(centerXSlider.value).toFixed(2);
                render();
            });
            centerYSlider.addEventListener('input', function() {
                centerOffsetY = parseFloat(centerYSlider.value);
                centerYValue.textContent = centerOffsetY.toFixed(2);
                render();
            });
        }

        editModeSelect.addEventListener('change', function() {
            const selectedMode = editModeSelect.value;
            isLittlePlanet = (selectedMode === 'little_planet');
            render();
        });

        scaleValue.addEventListener('click', function() { showInput(scaleValue, scaleInput, scaleSlider, false); });
        exponentialValue.addEventListener('click', function() { showInput(exponentialValue, exponentialInput, exponentialSlider, false); });
        pitchValue.addEventListener('click', function() { showInput(pitchValue, pitchInput, pitchSlider, true); });
        rollValue.addEventListener('click', function() { showInput(rollValue, rollInput, rollSlider, true); });
        yawValue.addEventListener('click', function() { showInput(yawValue, yawInput, yawSlider, true); });
        imgRotateValue.addEventListener('click', function() { showInput(imgRotateValue, imgRotateInput, imgRotateSlider, true); });
// å€¤è¡¨ç¤ºã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã«è¿½åŠ  20250817++ twister filter
swirlValue.addEventListener('click', function() { showInput(swirlValue, swirlInput, swirlSlider, false); });




        if (centerXValue && centerYValue) {
            centerXValue.addEventListener('click', function() { showInput(centerXValue, centerXInput, centerXSlider, false); });
            centerYValue.addEventListener('click', function() { showInput(centerYValue, centerYInput, centerYSlider, false); });
        }

        function showInput(valueDisplay, input, slider, isDegree) {
            const currentValue = isDegree ? valueDisplay.textContent.replace('Â°', '') : valueDisplay.textContent;
            input.value = currentValue;
            valueDisplay.style.display = 'none';
            input.style.display = 'inline-block';
            input.focus();
            input.select();
        }

        function hideInput(input, valueDisplay, slider, isDegree) {
            let newValue = parseFloat(input.value);
            if (isNaN(newValue)) {
                newValue = parseFloat(slider.value);
            } else {
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                newValue = Math.max(min, Math.min(max, newValue));
                slider.value = newValue;
            }
            if (isDegree) {
                valueDisplay.textContent = newValue.toFixed(2) + 'Â°';
                if (slider === pitchSlider) tempPitch = newValue;
                else if (slider === rollSlider) tempRoll = newValue;
                else if (slider === yawSlider) tempYaw = newValue;
                else if (slider === imgRotateSlider) tempImgRotate = newValue;
            } else {
                valueDisplay.textContent = newValue.toFixed(2);
                if (slider === scaleSlider) tempScale = newValue;
                else if (slider === exponentialSlider) tempExponential = newValue;
else if (slider === swirlSlider) tempSwirl = newValue; // â˜… è¿½åŠ  20250817++ twister filter
            }
            input.style.display = 'none';
            valueDisplay.style.display = 'inline-block';
            render();
        }

// å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚¤ãƒ™ãƒ³ãƒˆé…åˆ—ã«è¿½åŠ  20250817++ twister fliter swirlInput
        const pitchInputEls = [scaleInput, exponentialInput, pitchInput, rollInput, yawInput, imgRotateInput, swirlInput];
        pitchInputEls.forEach(el => {
            el?.addEventListener('blur', function() {

// æ—¢å­˜ã®mapã«ã‚‚è¿½åŠ  20250817++ twister fliter swirlInput
                const map = new Map([
                    [scaleInput, [scaleValue, scaleSlider, false]],
                    [exponentialInput, [exponentialValue, exponentialSlider, false]],
                    [pitchInput, [pitchValue, pitchSlider, true]],
                    [rollInput, [rollValue, rollSlider, true]],
                    [yawInput, [yawValue, yawSlider, true]],
                    [imgRotateInput, [imgRotateValue, imgRotateSlider, true]],
                    [swirlInput, [swirlValue, swirlSlider, false]]
                ]);
                const [v, s, d] = map.get(el);
                hideInput(el, v, s, d);
            });
            el?.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') el.blur();
            });
        });

        function hideInputCenter(input, valueDisplay, slider, axis) {
            let newValue = parseFloat(input.value);
            if (isNaN(newValue)) {
                newValue = parseFloat(slider.value);
            } else {
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                newValue = Math.max(min, Math.min(max, newValue));
                slider.value = newValue;
            }
            valueDisplay.textContent = newValue.toFixed(2);
            if (axis === 'X') {
                centerOffsetX = -newValue;
            } else if (axis === 'Y') {
                centerOffsetY = newValue;
            }
            input.style.display = 'none';
            valueDisplay.style.display = 'inline-block';
            render();
        }

        if (centerXInput && centerYInput) {
            centerXInput.addEventListener('blur', function() { hideInputCenter(centerXInput, centerXValue, centerXSlider, 'X'); });
            centerXInput.addEventListener('keydown', function(e) { if (e.key === 'Enter') hideInputCenter(centerXInput, centerXValue, centerXSlider, 'X'); });
            centerYInput.addEventListener('blur', function() { hideInputCenter(centerYInput, centerYValue, centerYSlider, 'Y'); });
            centerYInput.addEventListener('keydown', function(e) { if (e.key === 'Enter') hideInputCenter(centerYInput, centerYValue, centerYSlider, 'Y'); });
        }

        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        function normalizeAngle(angle, min, max) {
            const range = max - min;
            let normalized = angle % (range * 2);
            if (normalized > max) normalized -= range * 2;
            else if (normalized < min) normalized += range * 2;
            return Math.max(min, Math.min(max, normalized));
        }

        function handleTouchStart(e) {
            e.preventDefault();
            
    // æ„Ÿå¿œé ˜åŸŸãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ  20250814+
    if (!isInActiveArea(e.touches[0])) {
        return; // æ„Ÿå¿œé ˜åŸŸå¤–ãªã‚‰å‡¦ç†ã—ãªã„
    }
            
            
            
            
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                isPinching = false;
                isMovingCenter = false;
                tempPitch = parseFloat(pitchSlider.value);
                tempRoll = parseFloat(rollSlider.value);
                tempYaw = parseFloat(yawSlider.value);
            } else if (e.touches.length === 2) {
                isPinching = true;
                isDragging = false;
                isMovingCenter = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                tempScale = parseFloat(scaleSlider.value);
            } else if (e.touches.length === 3) {
                isMovingCenter = true;
                isDragging = false;
                isPinching = false;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                touchIndicator.style.display = 'block';
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
    // æ„Ÿå¿œé ˜åŸŸãƒã‚§ãƒƒã‚¯ 20250814+
    if (!isDragging && !isPinching && !isMovingCenter) {
        return;
    }            
            
            if (isDragging && e.touches.length === 1) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;

                tempRoll -= deltaX * 0.5;
                tempPitch += deltaY * 0.5;
                tempYaw -= deltaX * 0.5;

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                render();
            } else if (isPinching && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                const scaleChange = (currentDistance - lastPinchDistance) * 0.01;
                tempScale = Math.max(0.1, Math.min(3.9, tempScale + scaleChange));
                lastPinchDistance = currentDistance;
                render();
            } else if (isMovingCenter && e.touches.length === 3) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;

                centerOffsetX += deltaX * 0.005; // - 20250809
                centerOffsetY += deltaY * 0.005; // - 20250809

                centerOffsetX = Math.max(-1, Math.min(1, centerOffsetX));
                centerOffsetY = Math.max(-1, Math.min(1, centerOffsetY));

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                render();
            }
        }
        
        // æ„Ÿå¿œé ˜åŸŸåˆ¤å®šé–¢æ•°ï¼ˆã‚¿ãƒƒãƒç”¨ï¼‰
function isInActiveArea(touch) {
    const canvas = document.getElementById('canvas');
    const rect = canvas.getBoundingClientRect();
    
    // ã‚¿ãƒƒãƒä½ç½®ã‚’canvasåº§æ¨™ã«å¤‰æ›
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    // æ„Ÿå¿œé ˜åŸŸã®è¨­å®šï¼ˆä¾‹ï¼šcanvasä¸­å¤®ã®80%ï¼‰
    const margin = 0.1; // 10%ã®ãƒãƒ¼ã‚¸ãƒ³
    const activeLeft = rect.width * margin;
    const activeRight = rect.width * (1 - margin);
    const activeTop = rect.height * margin;
    const activeBottom = rect.height * (1 - margin);
    
    return x >= activeLeft && x <= activeRight && 
           y >= activeTop && y <= activeBottom;
}

// æ„Ÿå¿œé ˜åŸŸåˆ¤å®šé–¢æ•°ï¼ˆãƒã‚¦ã‚¹ç”¨ï¼‰
function isInActiveAreaMouse(event) {
    const canvas = document.getElementById('canvas');
    const rect = canvas.getBoundingClientRect();
    
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    const margin = 0.1;
    const activeLeft = rect.width * margin;
    const activeRight = rect.width * (1 - margin);
    const activeTop = rect.height * margin;
    const activeBottom = rect.height * (1 - margin);
    
    return x >= activeLeft && x <= activeRight && 
           y >= activeTop && y <= activeBottom;
}

        function handleTouchEnd(e) {
            e.preventDefault();
            if (isDragging) {
                tempPitch = normalizeAngle(tempPitch, -180, 180);
                tempRoll = normalizeAngle(tempRoll, -180, 180);
                tempYaw = normalizeAngle(tempYaw, -180, 180);
                pitchSlider.value = tempPitch;
                rollSlider.value = tempRoll;
                yawSlider.value = tempYaw;
                pitchValue.textContent = tempPitch.toFixed(2) + 'Â°';
                rollValue.textContent = tempRoll.toFixed(2) + 'Â°';
                yawValue.textContent = tempYaw.toFixed(2) + 'Â°';
                render();
            } else if (isPinching) {
                scaleSlider.value = tempScale;
                scaleValue.textContent = tempScale.toFixed(2);
                render();
            } else if (isMovingCenter) {
                touchIndicator.style.display = 'none';
            }
            isDragging = false;
            isPinching = false;
            isMovingCenter = false;
        }

        function handleMouseDown(e) {
            
    // ãƒã‚¦ã‚¹ç”¨ã®æ„Ÿå¿œé ˜åŸŸãƒã‚§ãƒƒã‚¯ 20250814+
    if (!isInActiveAreaMouse(e)) {
        return;
    }
            
            
            isDragging = true;
            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
            tempPitch = parseFloat(pitchSlider.value);
            tempRoll = parseFloat(rollSlider.value);
            tempYaw = parseFloat(yawSlider.value);
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - lastTouchX;
            const deltaY = e.clientY - lastTouchY;

            tempRoll -= deltaX * 0.5;
            tempPitch += deltaY * 0.5;
            tempYaw -= deltaX * 0.5;

            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
            render();
        }

        function handleMouseUp(e) {
            if (isDragging) {
                tempPitch = normalizeAngle(tempPitch, -180, 180);
                tempRoll = normalizeAngle(tempRoll, -180, 180);
                tempYaw = normalizeAngle(tempYaw, -180, 180);
                pitchSlider.value = tempPitch;
                rollSlider.value = tempRoll;
                yawSlider.value = tempYaw;
                pitchValue.textContent = tempPitch.toFixed(2) + 'Â°';
                rollValue.textContent = tempRoll.toFixed(2) + 'Â°';
                yawValue.textContent = tempYaw.toFixed(2) + 'Â°';
                render();
            }
            isDragging = false;
        }

        function sphericalToCartesian(theta, phi) {
            const x = Math.cos(phi) * Math.cos(theta);
            const y = Math.cos(phi) * Math.sin(theta);
            const z = Math.sin(phi);
            return [x, y, z];
        }

        function cartesianToSpherical(x, y, z) {
            const theta = Math.atan2(y, x);
            const phi = Math.asin(Math.max(-1, Math.min(1, z)));
            return [theta, phi];
        }

        function rotatePoint(x, y, z, pitch, roll, yaw) {
            const cp = Math.cos(pitch);
            const sp = Math.sin(pitch);
            const cr = Math.cos(roll);
            const sr = Math.sin(roll);
            const cy = Math.cos(yaw);
            const sy = Math.sin(yaw);

            const rx = x * (cy * cr - sy * sp * sr) + y * (-sy * cp) + z * (cy * sr + sy * sp * cr);
            const ry = x * (sy * cr + cy * sp * sr) + y * (cy * cp) + z * (sy * sr - cy * sp * cr);
            const rz = x * (-cp * sr) + y * sp + z * (cp * cr);

            return [rx, ry, rz];
        }

        function render() {
            if (!workingImage) return;

            const scale = tempScale;
            const exponential = tempExponential;
            let pitch = (tempPitch * Math.PI) / 180;
            const roll = (tempRoll * Math.PI) / 180;
            const yaw = (tempYaw * Math.PI) / 180;
            const imgRot = (tempImgRotate * Math.PI) / 180; // æœ€å¾Œæ®µ

            if (!isLittlePlanet) {
                pitch += Math.PI;
            }

            const size = 720;
            canvas.width = size;
            canvas.height = size;

            renderAtSize(size, scale, exponential, pitch, roll, yaw, imgRot, workingImage);
            
            drawGuideline();

        }
        
function drawGuideline() { // 20250814++
    const selectedType = document.getElementById('guidelineSelect').value;
    if (selectedType === 'none' || !guidelineImages[selectedType]) {
        // ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
        document.getElementById('guidelineRotateBtn').style.display = 'none';
        return;
    }
    
    // ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
    document.getElementById('guidelineRotateBtn').style.display = 'block';
    
    const guideline = guidelineImages[selectedType];
    
    ctx.save();
    ctx.globalAlpha = 0.6;
    
    // å›è»¢ã®ä¸­å¿ƒã‚’è¨­å®š
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate((guidelineRotation * Math.PI) / 180);
    ctx.translate(-canvas.width / 2, -canvas.height / 2);
    
    ctx.drawImage(guideline, 0, 0, canvas.width, canvas.height);
    ctx.restore();
}

// 20250817++ twister filter
function renderAtSize(size, scale, exponential, pitch, roll, yaw, imgRot, sourceImage) {
    const imageData = ctx.createImageData(size, size);
    const data = imageData.data;

    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = sourceImage.width;
    tempCanvas.height = sourceImage.height;
    tempCtx.drawImage(sourceImage, 0, 0);
    const sourceData = tempCtx.getImageData(0, 0, sourceImage.width, sourceImage.height);

    const cosA = Math.cos(imgRot);
    const sinA = Math.sin(imgRot);
    const swirlStrength = tempSwirl; // æ¸¦å·»ãå¼·åº¦ã‚’å–å¾—

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            // 0) å‡ºåŠ›åº§æ¨™ã‚’[-1,1]
            const nx0 = (x / (size - 1)) * 2 - 1;
            const ny0 = (y / (size - 1)) * 2 - 1;

            // 1) ã¾ãš 2Då›è»¢ã®é€†å¤‰æ›ï¼ˆè¦‹ãŸç›®ã§ã¯æœ€å¾Œã«å›ã™ãŸã‚ï¼‰
            const rx = nx0 * cosA + ny0 * sinA;
            const ry = -nx0 * sinA + ny0 * cosA;

            // 2) æ¬¡ã« X/Yã‚·ãƒ•ãƒˆã‚’æ‰“ã¡æ¶ˆã™ï¼ˆè¦‹ãŸç›®ã§ã¯ç›´å‰æ®µï¼‰
            const nx1 = rx - centerOffsetX;
            const ny1 = ry - centerOffsetY;

            // â˜… 3) æ–°è¦è¿½åŠ ï¼šæ¸¦å·»ãåŠ¹æœã®é€†å¤‰æ›ã‚’é©ç”¨
            const swirlResult = applySwirlEffect(nx1, ny1, -swirlStrength); // é€†å¤‰æ›ãªã®ã§ç¬¦å·åè»¢
            const nx = swirlResult.x;
            const ny = swirlResult.y;

            // 4) ä»¥é™ã¯çƒé¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†
            const r = Math.sqrt(nx * nx + ny * ny);
            const angle = Math.atan2(ny, nx);
            
            let mappedR;
            if (exponential === 0) {
                mappedR = 2 * Math.atan(r * (4 - scale));
            } else {
                const atanComponent = 2 * Math.atan(r * (4 - scale));
                const expComponent = Math.pow(r, 1 + exponential * 0.5) * Math.PI;
                const blendFactor = Math.min(exponential / 3.0, 1.0);
                mappedR = (1 - blendFactor) * atanComponent + blendFactor * expComponent;
            }
            
            const phi = Math.PI/2 - mappedR;
            const theta = angle;
            const cartesian = sphericalToCartesian(theta, phi);

            const rotated = rotatePoint(cartesian[0], cartesian[1], cartesian[2], pitch, roll, yaw);
            const spherical = cartesianToSpherical(rotated[0], rotated[1], rotated[2]);

            const u = (spherical[0] + Math.PI) / (2 * Math.PI);
            const v = (spherical[1] + Math.PI / 2) / Math.PI;

            const imgX = Math.floor(u * sourceImage.width) % sourceImage.width;
            const imgY = Math.floor(v * sourceImage.height) % sourceImage.height;

            if (imgX >= 0 && imgX < sourceImage.width && imgY >= 0 && imgY < sourceImage.height) {
                const sourceIndex = (imgY * sourceImage.width + imgX) * 4;
                const targetIndex = (y * size + x) * 4;

                data[targetIndex] = sourceData.data[sourceIndex];
                data[targetIndex + 1] = sourceData.data[sourceIndex + 1];
                data[targetIndex + 2] = sourceData.data[sourceIndex + 2];
                data[targetIndex + 3] = 255;
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent);
        }

        function processImageInChunks(canvas, ctx, outputSize, scale, exponential, pitch, roll, yaw, imgRot, chunkSize, currentY, callback) {
            const endY = Math.min(currentY + chunkSize, outputSize);
            const progress = Math.round((currentY / outputSize) * 100);
            document.getElementById('downloadBtn').textContent = 'ğŸ”„ ' + progress + '%';

            if (!processImageInChunks.sourceData) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = downloadImage.width;
                tempCanvas.height = downloadImage.height;
                tempCtx.drawImage(downloadImage, 0, 0);
                processImageInChunks.sourceData = tempCtx.getImageData(0, 0, downloadImage.width, downloadImage.height);
            }

            const sourceData = processImageInChunks.sourceData;
            const chunkHeight = endY - currentY;
            const imageData = ctx.createImageData(outputSize, chunkHeight);
            const data = imageData.data;

            const cosA = Math.cos(imgRot);
            const sinA = Math.sin(imgRot);
const swirlStrength = tempSwirl; // æ¸¦å·»ãå¼·åº¦ã‚’è¿½åŠ  20250817++ twister filter


            for (let y = 0; y < chunkHeight; y++) {
                for (let x = 0; x < outputSize; x++) {
                    const actualY = currentY + y;
                    const nx0 = (x / (outputSize - 1)) * 2 - 1;
                    const ny0 = (actualY / (outputSize - 1)) * 2 - 1;

                    // 1) 2Då›è»¢ã®é€†
                    const rx =  nx0 * cosA + ny0 * sinA;
                    const ry = -nx0 * sinA + ny0 * cosA;

                    // 2) ã‚·ãƒ•ãƒˆã®é€† 20250817++ twister filter
                    const nx1 = rx - centerOffsetX;
                    const ny1 = ry - centerOffsetY;
                    
                    
            
// â˜… 3) æ¸¦å·»ãåŠ¹æœã®é€†å¤‰æ›ã‚’è¿½åŠ  20250817++ twister filter
const swirlResult = applySwirlEffect(nx1, ny1, -swirlStrength);
const nx = swirlResult.x;
const ny = swirlResult.y;                    
                    
                    

                    // 4) çƒé¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    const r = Math.sqrt(nx * nx + ny * ny);
                    const angle = Math.atan2(ny, nx);
                    
                    let mappedR;
                    if (exponential === 0) {
                        mappedR = 2 * Math.atan(r * (4 - scale));
                    } else {
                        const atanComponent = 2 * Math.atan(r * (4 - scale));
                        const expComponent = Math.pow(r, 1 + exponential * 0.5) * Math.PI;
                        const blendFactor = Math.min(exponential / 3.0, 1.0);
                        mappedR = (1 - blendFactor) * atanComponent + blendFactor * expComponent;
                    }
                    
                    const phi = Math.PI/2 - mappedR;
                    const theta = angle;
                    const cartesian = sphericalToCartesian(theta, phi);

                    const rotated = rotatePoint(cartesian[0], cartesian[1], cartesian[2], pitch, roll, yaw);
                    const spherical = cartesianToSpherical(rotated[0], rotated[1], rotated[2]);

                    const u = (spherical[0] + Math.PI) / (2 * Math.PI);
                    const v = (spherical[1] + Math.PI / 2) / Math.PI;

                    const imgX = Math.floor(u * downloadImage.width) % downloadImage.width;
                    const imgY = Math.floor(v * downloadImage.height) % downloadImage.height;

                    if (imgX >= 0 && imgX < downloadImage.width && imgY >= 0 && imgY < downloadImage.height) {
                        const sourceIndex = (imgY * downloadImage.width + imgX) * 4;
                        const targetIndex = (y * outputSize + x) * 4;

                        data[targetIndex] = sourceData.data[sourceIndex];
                        data[targetIndex + 1] = sourceData.data[sourceIndex + 1];
                        data[targetIndex + 2] = sourceData.data[sourceIndex + 2];
                        data[targetIndex + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, currentY);

            if (endY < outputSize) {
                setTimeout(function() {
                    processImageInChunks(canvas, ctx, outputSize, scale, exponential, pitch, roll, yaw, imgRot, chunkSize, endY, callback);
                }, 10);
            } else {
                delete processImageInChunks.sourceData;
                callback();
            }
        }

        document.getElementById('downloadBtn').addEventListener('click', function() {
            if (!downloadImage) return;

            const outputSize = parseInt(resolutionSelect.value);
            const outputFormat = formatSelect.value;
            const scale = parseFloat(scaleSlider.value);
            const exponential = parseFloat(exponentialSlider.value);
            let pitch = (parseFloat(pitchSlider.value) * Math.PI) / 180;
            const roll = (parseFloat(rollSlider.value) * Math.PI) / 180;
            const yaw = (parseFloat(yawSlider.value) * Math.PI) / 180;
            const imgRot = (parseFloat(imgRotateSlider.value) * Math.PI) / 180; // æœ€å¾Œæ®µ

            if (!isLittlePlanet) {
                pitch += Math.PI;
            }

            const estimatedMemory = outputSize * outputSize * 4 * 3;
            const deviceMemory = navigator.deviceMemory || 2;
            
            if (outputSize >= 4096 && deviceMemory < 4) {
                if (!confirm('é«˜è§£åƒåº¦å‡ºåŠ›ã¯å¤§é‡ã®ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã—ã¾ã™ã€‚å¤ã„ç«¯æœ«ã§ã¯å‹•ä½œãŒä¸å®‰å®šã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ')) {
                    return;
                }
            }

            console.log('Generating ' + outputSize + 'Ã—' + outputSize + ' image from download source ' + downloadImage.width + 'Ã—' + downloadImage.height + '...');

            const downloadBtn = document.getElementById('downloadBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.textContent = 'ğŸ”„ Processing...';
            downloadBtn.disabled = true;

            let newWindow = null;
            if (isIOS()) {
                newWindow = window.open('about:blank', '_blank');
                if (!newWindow) {
                    alert('ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚');
                    downloadBtn.textContent = originalText;
                    downloadBtn.disabled = false;
                    return;
                }
                const countdownTime = outputSize >= 4096 ? 30 : 15;
                const resolutionText = outputSize === 2048 ? '2K' : outputSize === 4096 ? '4K' : 'preview';
                const modeText = isLittlePlanet ? 'little_planet' : 'rabbit_hole';
                const filename = modeText + '_' + resolutionText;
                
                newWindow.document.write('<!DOCTYPE html><html><head><title>' + filename + '</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>body { margin: 0; padding: 20px; background: linear-gradient(135deg, #1e3c72, #2a5298); display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: -apple-system, BlinkMacSystemFont, sans-serif; color: white; } .spinner { width: 60px; height: 60px; border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin: 20px 0; } .back-btn { background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; margin: 20px 0; cursor: pointer; transition: background 0.3s; } .back-btn:hover { background: #0056CC; } .status-line { font-size: 20px; font-weight: bold; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }</style></head><body><div class="spinner"></div><button class="back-btn" onclick="window.close()">Return</button><div class="status-line" id="statusLine">Processing... ' + countdownTime + '</div></body></html>');
                
                let countdown = countdownTime;
                const statusElement = newWindow.document.getElementById('statusLine');
                const countdownInterval = setInterval(function() {
                    countdown--;
                    if (statusElement) {
                        if (countdown > 0) {
                            statusElement.textContent = 'Processing... ' + countdown;
                        } else {
                            statusElement.textContent = 'Processing...';
                            clearInterval(countdownInterval);
                        }
                    } else {
                        clearInterval(countdownInterval);
                    }
                }, 1000);
            }

            setTimeout(function() {
                try {
                    const downloadCanvas = document.createElement('canvas');
                    const downloadCtx = downloadCanvas.getContext('2d');
                    downloadCanvas.width = outputSize;
                    downloadCanvas.height = outputSize;

                    const chunkSize = outputSize >= 4096 ? 64 : outputSize >= 2048 ? 128 : 256;
                    
                    processImageInChunks(downloadCanvas, downloadCtx, outputSize, scale, exponential, pitch, roll, yaw, imgRot, chunkSize, 0, function() {
                        const resolutionText = outputSize === 2048 ? '2K' : outputSize === 4096 ? '4K' : 'preview';
                        const modeText = isLittlePlanet ? 'little_planet' : 'rabbit_hole';
                        
                        const now = new Date();
                        const timestamp = now.getFullYear().toString() + 
                                        (now.getMonth() + 1).toString().padStart(2, '0') + 
                                        now.getDate().toString().padStart(2, '0') + '_' +
                                        now.getHours().toString().padStart(2, '0') + 
                                        now.getMinutes().toString().padStart(2, '0') + 
                                        now.getSeconds().toString().padStart(2, '0');
                        
                        let dataURL;
                        let fileExtension;
                        
                        if (outputFormat === 'jpeg') {
                            dataURL = downloadCanvas.toDataURL('image/jpeg', 0.8);
                            fileExtension = 'jpg';
                        } else {
                            dataURL = downloadCanvas.toDataURL('image/png');
                            fileExtension = 'png';
                        }
                        
                        const filename = modeText + '_' + resolutionText + '_exp' + exponential.toFixed(1) + '_imgRot' + (parseFloat(imgRotateSlider.value)||0).toFixed(0) + '_' + timestamp + '.' + fileExtension;

                        if (isIOS() && newWindow) {
                            const imgElement = newWindow.document.createElement('img');
                            imgElement.src = dataURL;
                            imgElement.alt = filename;
                            imgElement.style.cssText = 'width: min(90vw, 80vh); height: min(90vw, 80vh); object-fit: contain; border-radius: 10px; box-shadow: 0 4px 20px rgba(255,255,255,0.1); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; background: rgba(0,0,0,0.8); padding: 10px;';
                            
                            const instructionsDiv = newWindow.document.createElement('div');
                            instructionsDiv.innerHTML = 'Download or Share: Long press the image';
                            instructionsDiv.style.cssText = 'color: white; text-align: center; font-size: 16px; line-height: 1.5; position: absolute; top: calc(50% + min(45vw, 40vh) + 30px); left: 50%; transform: translateX(-50%); z-index: 1001;';
                            
                            const backBtn = newWindow.document.createElement('button');
                            backBtn.innerHTML = 'Return';
                            backBtn.onclick = function() { newWindow.close(); };
                            backBtn.style.cssText = 'background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; cursor: pointer; transition: background 0.3s; position: absolute; top: calc(50% + min(45vw, 40vh) + 80px); left: 50%; transform: translateX(-50%); z-index: 1001;';
                            backBtn.onmouseover = function() { this.style.background = '#0056CC'; };
                            backBtn.onmouseout = function() { this.style.background = '#007AFF'; };
                            
                            newWindow.document.body.appendChild(imgElement);
                            newWindow.document.body.appendChild(instructionsDiv);
                            newWindow.document.body.appendChild(backBtn);
                        } else if (!isIOS()) {
                            const link = document.createElement('a');
                            link.download = filename;
                            link.href = dataURL;
                            link.click();
                        }

                        downloadBtn.textContent = originalText;
                        downloadBtn.disabled = false;
                    });
                } catch (error) {
                    console.error('Download failed:', error);
                    alert('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ¡ãƒ¢ãƒªä¸è¶³ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚è§£åƒåº¦ã‚’ä¸‹ã’ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚');
                    if (newWindow) newWindow.close();
                    const downloadBtn = document.getElementById('downloadBtn');
                    downloadBtn.textContent = 'ğŸ“‚ Download';
                    downloadBtn.disabled = false;
                }
            }, 100);
        });
        
        // ãƒ©ãƒ³ãƒ€ãƒ åŒ–é–¢æ•°
        function randomizeAllSliders() {
            const sliderConfigs = [
                { id: 'scaleSlider', valueId: 'scaleValue', inputId: 'scaleInput', unit: '', tempVar: 'tempScale' },
                { id: 'exponentialSlider', valueId: 'exponentialValue', inputId: 'exponentialInput', unit: '', tempVar: 'tempExponential' },
                { id: 'pitchSlider', valueId: 'pitchValue', inputId: 'pitchInput', unit: 'Â°', tempVar: 'tempPitch' },
                { id: 'rollSlider', valueId: 'rollValue', inputId: 'rollInput', unit: 'Â°', tempVar: 'tempRoll' },
                { id: 'yawSlider', valueId: 'yawValue', inputId: 'yawInput', unit: 'Â°', tempVar: 'tempYaw' }//,
//{ id: 'swirlSlider', valueId: 'swirlValue', inputId: 'swirlInput', unit: '', tempVar: 'tempSwirl' } // è¿½åŠ  20250817++ twister filter

            ];
        
            sliderConfigs.forEach(config => {
                const slider = document.getElementById(config.id);
                const valueDisplay = document.getElementById(config.valueId);
                const inputField = document.getElementById(config.inputId);
                
                if (slider) {
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const step = parseFloat(slider.step);
                    
                    // stepã‚’è€ƒæ…®ã—ãŸãƒ©ãƒ³ãƒ€ãƒ å€¤ç”Ÿæˆ
                    const range = (max - min) / step;
                    const randomSteps = Math.floor(Math.random() * (range + 1));
                    const randomValue = min + (randomSteps * step);
                    
                    // å€¤ã‚’è¨­å®š
                    slider.value = randomValue;
                    
                    // è¡¨ç¤ºã‚’æ›´æ–°
                    if (valueDisplay) {
                        valueDisplay.textContent = randomValue.toFixed(2) + config.unit;
                    }
                    if (inputField) {
                        inputField.value = randomValue.toFixed(2) + (config.unit === 'Â°' ? '' : '');
                    }
                    
                    // tempå¤‰æ•°ã‚’æ›´æ–°
                    switch(config.tempVar) {
                        case 'tempScale': tempScale = randomValue; break;
                        case 'tempExponential': tempExponential = randomValue; break;
                        case 'tempPitch': tempPitch = randomValue; break;
                        case 'tempRoll': tempRoll = randomValue; break;
                        case 'tempYaw': tempYaw = randomValue; break;
case 'tempSwirl': tempSwirl = randomValue; break; // è¿½åŠ  20250817++ twister filter

                    }
                }
            });
            
            // ç”»é¢ã‚’å†æç”»
            render();
        }
        
        
        
        // æ¸¦å·»ãå¤‰æ›é–¢æ•°ã‚’è¿½åŠ ï¼ˆæ—¢å­˜ã®é–¢æ•°ç¾¤ã®å¾Œã«ï¼‰20250817++ twister filter
function applySwirlEffect(nx, ny, swirlStrength) {
    if (Math.abs(swirlStrength) < 0.01) {
        return { x: nx, y: ny }; // åŠ¹æœãªã—ã®å ´åˆã¯ãã®ã¾ã¾è¿”ã™
    }
    
    // ä¸­å¿ƒã‹ã‚‰ã®è·é›¢ã‚’è¨ˆç®—
    const r = Math.sqrt(nx * nx + ny * ny);
    
    // ä¸­å¤®1/5ã¯å¤‰åŒ–ãªã—ã€ãã®å¾Œå¾ã€…ã«æ¸¦å·»ãåŠ¹æœã‚’å¼·ãã™ã‚‹
    const innerRadius = 0.1; // ä¸­å¤®ã®1/10
    let effectStrength = 0;
    
    if (r > innerRadius) {
        // ä¸­å¤®ã‹ã‚‰å¤–å´ã«å‘ã‹ã£ã¦åŠ¹æœã‚’å¼·ãã™ã‚‹ï¼ˆ2æ¬¡é–¢æ•°çš„ï¼‰
        const normalizedDistance = (r - innerRadius) / (1.0 - innerRadius);
        effectStrength = normalizedDistance * normalizedDistance * swirlStrength;
    }
    
    // ç¾åœ¨ã®è§’åº¦ã‚’è¨ˆç®—
    const currentAngle = Math.atan2(ny, nx);
    
    // æ¸¦å·»ãå›è»¢è§’åº¦ã‚’è¨ˆç®—ï¼ˆè·é›¢ã«å¿œã˜ã¦å¤‰åŒ–ï¼‰
    const swirlAngle = effectStrength * Math.PI; // æœ€å¤§180åº¦å›è»¢
    
    // æ–°ã—ã„è§’åº¦
    const newAngle = currentAngle + swirlAngle;
    
    // æ–°ã—ã„åº§æ¨™ã‚’è¨ˆç®—
    const newX = r * Math.cos(newAngle);
    const newY = r * Math.sin(newAngle);
    
    return { x: newX, y: newY };
}
        
        
        
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ ï¼ˆæ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã®æœ€å¾Œã«è¿½åŠ ï¼‰
        document.getElementById('randomBtn').addEventListener('click', randomizeAllSliders);
        
    </script>
</body>
</html>
