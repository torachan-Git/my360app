<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360onWeb - Fixed</title>
    <style>
        :root {
            --bg-gradient-start: #9e3c72;
            --bg-gradient-end: #2a5298;
            --slider-grdnt-start: #4CAF50;
            --slider-grdnt-end: #2196F3;
            --upload-area-border--: 3px dashed #4CAF50;
            --upload-area-bg--: rgba(255,255,255,0.1);
            --upload-hover-border--: #45a049;
            --upload-hover-bg--: rgba(255,255,255,0.15);
            --upload-dragover-border--: #2196F3;
            --upload-dragover-bg--: rgba(33,150,243,0.2);
            --upload-btn--: #4CAF50;
            --upload-btn-hover--: #45a049;
            --random-btn--: #FF6B6B;
            --download-btn-bg--: linear-gradient(45deg, #667eea, #764ba2);
            --download-btn-hover--: rgba(0,0,0,0.3);
            --undo-btn-bg--: linear-gradient(45deg, #FF6B6B, #FFB347);
            --undo-btn-hover--: rgba(255,107,107,0.3);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
            color: white;
            min-height: 100vh;
        }
    
        .container {
            max-width: 1524px;
            margin: 0 auto;
        }
    
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: 24px;
        }

        .upload-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: nowrap;
        }
    
        .app-title {
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        
        .upload-area {
            border: var(--upload-area-border--);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            background: var(--upload-area-bg--);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
    
        .upload-area:hover {
            border-color: var(--upload-hover-border--);
            background: var(--upload-hover-bg--);
        }
    
        .upload-area.dragover {
            border-color: var(--upload-dragover-border--);
            background: var(--upload-dragover-bg--);
        }
    
        input[type="file"] {
            display: none;
        }
    
        .upload-btn {
            background: var(--upload-btn--);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
            white-space: nowrap;
        }
    
        .upload-btn:hover {
            background: var(--upload-btn-hover--);
        }
    
        .random-btn {
            width: 5%;
            background: transparent;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 32px;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .random-btn:hover {
            transform: scale(1.1);
        }
    
        .main-content {
            display: none;
        }
    
        .editor-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }
    
        .canvas-container {
            flex: 1;
            text-align: center;
        }
    
        .canvas-wrapper {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            position: relative;
        }
    
        canvas {
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 100%;
            height: auto;
            touch-action: none;
            cursor: grab;
        }
    
        canvas:active {
            cursor: grabbing;
        }
    
        .controls {
            width: 300px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
    
        .control-group {
            margin-bottom: 18px;
        }
    
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
            color: #f0f0f0;
        }
    
        .label-text {
            text-align: left;
        }
    
        .value-display {
            font-size: 14px;
            color: #ddd;
            text-align: right;
            min-width: 70px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
    
        .value-display:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }
    
        .value-input {
            font-size: 14px;
            color: white;
            text-align: right;
            min-width: 70px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #4CAF50;
            border-radius: 4px;
            padding: 2px 6px;
            outline: none;
        }
    
        .slider-container {
            position: relative;
        }
        
        .slider-with-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-btn {
            width: 30px;
            height: 30px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .slider-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }

        .slider-with-buttons input[type="range"] {
            flex: 1;
        }
    
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--slider-grdnt-start), var(--slider-grdnt-end));
            outline: none;
            -webkit-appearance: none;
        }
    
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    
        .download-btn {
            width: 100%;
            background: var(--download-btn-bg--);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
    
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--download-btn-hover--);
        }
    
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
    
        .loading-content {
            text-align: center;
            color: white;
            font-size: 18px;
        }
    
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
    
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    
        .touch-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }
        
        .guideline-rotate-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            z-index: 15;
            transition: background 0.3s;
        }

        .guideline-rotate-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .guideline-select {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
            min-width: 100px;
            flex-shrink: 0;
        }
        
        .guideline-select:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .guideline-select option {
            background: #333;
            color: white;
        }
        
        
        
        
/* Undo/Redoオーバーレイ用のスタイル */
.undo-redo-overlay {
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 10;
}

.undo-btn-overlay {
    width: 50px;
    height: 25px;
    background: rgba(255,107,107,0.4);
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 20px;
    font-weight: 600;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
}

.undo-btn-overlay:not(:disabled):hover {
    background: rgba(255,107,107,1);
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(255,107,107,0.4);
}

.undo-btn-overlay:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    background: rgba(128,128,128,0.2);
}

#redoBtn.undo-btn-overlay {
    background: rgba(76,175,80,0.4);
}

#redoBtn.undo-btn-overlay:not(:disabled):hover {
    background: rgba(76,175,80,1);
    box-shadow: 0 4px 12px rgba(76,175,80,0.4);
}
        
        
        
        
        
.icon-btn{
  /* 見えない“円形ヒット領域”は残す（当たり判定＆フォーカスリング用） */
  width: 40px; height: 40px;
  display: grid; place-items: center;
  border: none; border-radius: 50%;
  background: transparent; color: #fff;
  cursor: pointer; outline: none;
/* 追加：キャンバス上に重ねる */
position: absolute;
top: 10px;
left: 10px;
z-index: 15;
}

.icon-btn .emoji{
  font-size: 22px; line-height: 1;   /* 行ボックスの影響を排除 */
  opacity: .65;                       /* ← 絵文字を半透明にするポイント */
  transform: translateY(var(--nudge-y, 0)); /* ベースライン微調整用（必要時のみ） */
}

/* ホバー/フォーカスの視認性（円は“見えない/淡い”だけで残す） */
.icon-btn:hover { background: rgba(255,255,255,0.08); }
.icon-btn:active{ background: rgba(255,255,255,0.14); }
.icon-btn:focus-visible{
  box-shadow: 0 0 0 2px rgba(255,255,255,.35);
}

  
        
        

        /* レスポンシブレイアウト */
        @media screen and (orientation: portrait) {
            .container {
                display: flex;
                flex-direction: column;
                width: 100%;
                margin: 0 auto;
            }
            
            .upload-area {
                width: 100% !important;
                margin-bottom: 20px;
                box-sizing: border-box;
            }
            
            .editor-container {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            
            .canvas-container {
                width: 100% !important;
                box-sizing: border-box;
            }
            
            .controls {
                width: 100% !important;
                margin: 0;
                box-sizing: border-box;
            }
            
            .canvas-wrapper {
                padding: 15px;
                box-sizing: border-box;
            }
            
            .controls {
                padding: 20px;
                box-sizing: border-box;
            }
        }

        @media screen and (orientation: landscape) {
            .container {
                display: flex;
                flex-direction: column;
            }
            
            .upload-area {
                width: 96%;
                margin-bottom: 20px;
                order: -1;
            }
            
            .editor-container {
                display: flex;
                flex-direction: row;
                gap: 20px;
            }
            
            .canvas-container {
                flex: 1;
                width: 50%;
            }
            
            .controls {
                flex: 1;
                width: 50%;
                margin: 0;
            }
        }

        @media (max-width: 768px) {
            .editor-container {
                gap: 10px;
            }
            
            .canvas-wrapper {
                padding: 15px;
            }
            
            .controls {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="upload-area" id="uploadArea">
            <div class="upload-header">
                <button class="upload-btn" onclick="resetControlsAndSelectFile()">
                    🖼️+360onWeb
                </button>
                <select id="guidelineSelect" class="guideline-select">
                    <option value="none">ガイドなし(1～16)</option>
                    <option value="line01"> 1.同心円</option>
                    <option value="line02"> 2.三重円</option>
                    <option value="line03"> 3.円分割</option>
                    <option value="line04"> 4.しぼり</option>
                    <option value="line05"> 5.渦巻き</option>
                    <option value="line06"> 6.三分割</option>
                    <option value="line07"> 7.四分割</option>
                    <option value="line08"> 8.放射分割</option>
                    <option value="line09"> 9.斜め分割</option>
                    <option value="line10">10.遠近斜め</option>
                    <option value="line11">11.遠近水平</option>
                    <option value="line12">12.フィボナッチ</option>
                    <option value="line13">13.S字</option>
                    <option value="line14">14.U字</option>
                    <option value="line15">15.二つ窓</option>
                    <option value="line16">16.電影クロスゲージ</option>
                </select>
                <!-- <button class="random-btn" id="randomBtn">🤯</button>  -->
            </div>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="main-content" id="mainContent">
            <div class="editor-container">
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <canvas id="canvas" width="720" height="720"></canvas>
                
<!--                        <button id="guidelineRotateBtn" class="guideline-rotate-btn" style="display: none;">🔄</button>-->
                
                
<button id="guidelineRotateBtn" class="icon-btn" aria-label="ガイド回転" title="回転(45°)">
<span class="emoji" aria-hidden="true">🔄</span>
</button>
                
                
                        <div class="touch-indicator" id="touchIndicator">Move Center</div>
                        
                        
                            <!-- この部分を追加 -->
    <div class="undo-redo-overlay">
        <button class="undo-btn-overlay" id="undoBtn" disabled>↺</button>
        <button class="undo-btn-overlay" id="redoBtn" disabled>↻</button>
    </div>
                        
                        
                    </div>

                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <div class="control-label">
                            <span class="label-text">🔍 Zoom 拡大縮小</span>
                            <input type="text" class="value-input" id="scaleInput" value="1.5" style="display: none;">
                            <span class="value-display" id="scaleValue">1.5</span>
                        </div>
                        <div class="slider-container">
                            <div class="slider-with-buttons">
                                <button class="slider-btn" onclick="decrementSlider('scaleSlider')">−</button>
                                <input type="range" id="scaleSlider" min="0.1" max="2.9" step="0.1" value="1.5">
                                <button class="slider-btn" onclick="incrementSlider('scaleSlider')">+</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span class="label-text">Pitch ピッチ</span>
                            <input type="text" class="value-input" id="pitchInput" value="0°" style="display: none;">
                            <span class="value-display" id="pitchValue">0.0°</span>
                        </div>
                        <div class="slider-container">
                            <div class="slider-with-buttons">
                                <button class="slider-btn" onclick="incrementSlider('pitchSlider')">−</button>
                                <input type="range" id="pitchSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                                <button class="slider-btn" onclick="decrementSlider('pitchSlider')">+</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label">
                            <span class="label-text">Roll ロール</span>
                            <input type="text" class="value-input" id="rollInput" value="0°" style="display: none;">
                            <span class="value-display" id="rollValue">0.0°</span>
                        </div>
                        <div class="slider-container">
                            <div class="slider-with-buttons">
                                <button class="slider-btn" onclick="incrementSlider('rollSlider')">−</button>
                                <input type="range" id="rollSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                                <button class="slider-btn" onclick="decrementSlider('rollSlider')">+</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span class="label-text">🔃 Rotate 回転</span>
                            <input type="text" class="value-input" id="imgRotateInput" value="0°" style="display: none;">
                            <span class="value-display" id="imgRotateValue">0.0°</span>
                        </div>
                        <div class="slider-container">
                            <div class="slider-with-buttons">
                                <button class="slider-btn" onclick="decrementSlider('imgRotateSlider')">−</button>
                                <input type="range" id="imgRotateSlider" min="-180" max="180" step="1" value="0">
                                <button class="slider-btn" onclick="incrementSlider('imgRotateSlider')">+</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;"> 
                        <label for="editModeSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        Edit type
                        </label>
                        <select id="editModeSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="little_planet" style="background: #333; color: white;">Little Planet</option>
                            <option value="rabbit_hole" style="background: #333; color: white;">Rabbit Hole</option>
                        </select>
                    </div>

                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;"> 
                        <label for="formatSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        Format type
                        </label>
                        <select id="formatSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="jpeg" style="background: #333; color: white;">JPG 80%</option>
                            <option value="png" style="background: #333; color: white;">PNG</option>
                        </select>
                    </div>

                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <label for="resolutionSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        Export size
                        </label>
                        <select id="resolutionSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="1024" style="background: #333; color: white;">1024×1024 (1K)</option>
                            <option value="2048" style="background: #333; color: white;">2048×2048 (2K)</option>
                            <option value="4096" style="background: #333; color: white;">4096×4096 (4K)</option>
                            <option value="4096+" style="background: #333; color: white;">4096×4096 (+4K)</option>

                        </select>
                    </div>

                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <label for="workingResolutionSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        Preview Res.
                        </label>
                        <select id="workingResolutionSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="256" style="background: #333; color: white;">Quick（速度重視）</option>
                            <option value="512" style="background: #333; color: white;" selected>Balanced（標準）</option>
                            <option value="1024" style="background: #333; color: white;">Detailed（表示重視）</option>
                        </select>
                    </div>
                    
                    <button class="download-btn" id="downloadBtn">📂 Download</button>
                </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loadingText">Processing image...</div>
        </div>
    </div>

    <script>
        let originalImage = null;
        let workingImage = null;
        let downloadImage = null;
        let isLittlePlanet = true;
        let guidelineImages = {};
        let guidelineRotation = 0;
        
        
// プレビュー用キャッシュ（毎フレームの getImageData を排除）
let workingSourceData = null;
// 入力を1フレームに合流
let framePending = false;
        

        // Undo機能用の変数
        let stateHistory = [];
        let currentStateIndex = -1;
        const MAX_HISTORY = 20; // 最大20回までのUndoを保存

        const guidelineTypes = ['line01', 'line02', 'line03', 'line04', 'line05', 'line06', 'line07', 'line08', 'line09', 'line10', 'line11', 'line12', 'line13', 'line14', 'line15', 'line16'];

        // DOM要素の取得

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const mainContent = document.getElementById('mainContent');
        const touchIndicator = document.getElementById('touchIndicator');

        const scaleSlider = document.getElementById('scaleSlider');
        const pitchSlider = document.getElementById('pitchSlider');
        const rollSlider = document.getElementById('rollSlider');
        const imgRotateSlider = document.getElementById('imgRotateSlider');
        const editModeSelect = document.getElementById('editModeSelect');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const formatSelect = document.getElementById('formatSelect');
        const workingResolutionSelect = document.getElementById('workingResolutionSelect');

        const scaleValue = document.getElementById('scaleValue');
        const pitchValue = document.getElementById('pitchValue');
        const rollValue = document.getElementById('rollValue');
        const imgRotateValue = document.getElementById('imgRotateValue');

        const scaleInput = document.getElementById('scaleInput');
        const pitchInput = document.getElementById('pitchInput');
        const rollInput = document.getElementById('rollInput');
        const imgRotateInput = document.getElementById('imgRotateInput');

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');


        // タッチ・マウス操作用変数
        let isDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let lastPinchDistance = 0;
        let isPinching = false;
        let isMovingCenter = false;
        let tempScale = parseFloat(scaleSlider.value) || 1.5;
        let tempPitch = parseFloat(pitchSlider.value) || 0;
        let tempRoll = parseFloat(rollSlider.value) || 0;
        let tempImgRotate = parseFloat(imgRotateSlider.value) || 0;


// rAF 合流
function scheduleRender() {
    if (framePending) return;
    framePending = true;
    requestAnimationFrame(() => { framePending = false; render(); });
}

// Display size に連動したプレビュー解像度（軽量化）
function getPreviewCanvasSize() {
    const s = parseInt(workingResolutionSelect.value, 10); // 256/512/1024
    if (s <= 256) return 384;   // Fast
    if (s <= 512) return 720;   // Standard（従来）
    return 960;                 // Quality（まだ軽い）
}


// Display sizeの保存・読み込み機能
function saveDisplaySize() {
    const selectedSize = workingResolutionSelect.value;
    localStorage.setItem('360onweb_displaySize', selectedSize);
}

function loadDisplaySize() {
    const savedSize = localStorage.getItem('360onweb_displaySize');
    if (savedSize && workingResolutionSelect) {
        // 保存された値が選択肢に存在するかチェック
        const options = Array.from(workingResolutionSelect.options).map(opt => opt.value);
        if (options.includes(savedSize)) {
            workingResolutionSelect.value = savedSize;
        }
    }
}





        // Undo機能の実装
        function saveState() {
            const state = {
                scale: tempScale,
                pitch: tempPitch,
                roll: tempRoll,
                imgRotate: tempImgRotate
            };
            
            // 現在の位置以降の履歴を削除（新しい操作があった場合）
            stateHistory = stateHistory.slice(0, currentStateIndex + 1);
            
            // 新しい状態を追加
            stateHistory.push(state);
            currentStateIndex++;
            
            // 履歴の上限を超えた場合、古い履歴を削除
            if (stateHistory.length > MAX_HISTORY) {
                stateHistory.shift();
                currentStateIndex--;
            }
            
            updateUndoRedoButtons();
        }

        function undo() {
            if (currentStateIndex > 0) {
                currentStateIndex--;
                const state = stateHistory[currentStateIndex];
                restoreState(state);
                updateUndoRedoButtons();
            }
        }
        
        // Redo関数
function redo() {
    if (currentStateIndex < stateHistory.length - 1) {
        currentStateIndex++;                           // 履歴を1つ進める
        const state = stateHistory[currentStateIndex]; // 次の状態を取得
        restoreState(state);                          // 状態を復元
        updateUndoRedoButtons();                      // ボタンの更新
    }
}

        function restoreState(state) {
            // 値を復元
            tempScale = state.scale;
            tempPitch = state.pitch;
            tempRoll = state.roll;
            tempImgRotate = state.imgRotate;
            
            // スライダーの値を更新
            scaleSlider.value = tempScale;
            pitchSlider.value = tempPitch;
            rollSlider.value = tempRoll;
            imgRotateSlider.value = tempImgRotate;
            
            // 表示値を更新
            scaleValue.textContent = tempScale.toFixed(1);
            pitchValue.textContent = tempPitch.toFixed(1) + '°';
            rollValue.textContent = tempRoll.toFixed(1) + '°';
            imgRotateValue.textContent = tempImgRotate.toFixed(1) + '°';
            
            // 入力フィールドの値も更新
            scaleInput.value = tempScale.toFixed(1);
            pitchInput.value = tempPitch.toFixed(1);
            rollInput.value = tempRoll.toFixed(1);
            imgRotateInput.value = tempImgRotate.toFixed(1);
            
// 再描画
scheduleRender();
        }


// ボタン更新関数を修正
function updateUndoRedoButtons() {
    undoBtn.disabled = currentStateIndex <= 0;
    redoBtn.disabled = currentStateIndex >= stateHistory.length - 1;
}



        function clearHistory() {
            stateHistory = [];
            currentStateIndex = -1;
            updateUndoRedoButtons();
        }

        window.addEventListener('load', function() {
// Display sizeの復元を先に
loadDisplaySize();
loadSampleImage();
loadGuidelineImages();
            
            const guidelineSelect = document.getElementById('guidelineSelect');
            guidelineSelect.addEventListener('change', function() {
                guidelineRotation = 0;
                scheduleRender();
            });

            document.getElementById('guidelineRotateBtn').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                guidelineRotation = (guidelineRotation + 45) % 360;
                scheduleRender();
            });

            // ワーキングサイズ変更のイベントリスナーを追加
            workingResolutionSelect.addEventListener('change', function() {
                if (originalImage) {
                    createWorkingImages();
                }
// 保存機能を追加
saveDisplaySize();
            });

            // Undoボタンのイベントリスナー
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

        });

        function showLoading(text) {
            const overlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = text;
            overlay.style.display = 'flex';
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = 'none';
        }

        function loadSampleImage() {
            if (location.protocol === 'file:') {
                console.log('Local environment detected. Sample image loading skipped.');
                return;
            }
            const sampleImage = new Image();
            sampleImage.onload = function() {
                originalImage = sampleImage;
                createWorkingImages();
            };
            sampleImage.onerror = function() {
                console.log('sample4k.jpg is not available. select 360 image');
            };
            sampleImage.src = './sample4k.jpg';
        }
        
        // 構図ガイドライン画像の読み込み
        function loadGuidelineImages() {
            if (location.protocol === 'file:') {
                console.log('Local environment detected. Guideline images loading skipped.');
                return;
            }
        
            guidelineTypes.forEach(type => {
                const img = new Image();
                img.onload = function() {
                    guidelineImages[type] = img;
                    console.log(`Guideline image loaded: ${type}`);
                };
                img.onerror = function() {
                    console.log(`Guideline image not found: lines/${type}.png`);
                };
                img.src = `./lines/${type}.png`;
            });
        }

        function resetControlsAndSelectFile() {
            resetControls();
            document.getElementById('fileInput').click();
        }

        // ファイル操作
        fileInput.addEventListener('change', handleFile);
        
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function() {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                resetControls();
                processFile(files[0]);
            }
        });

        function handleFile(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('画像ファイルを選択してください！');
                return;
            }

            showLoading('Loading image...');

            const reader = new FileReader();
            reader.onload = function(e) {
                originalImage = new Image();
                originalImage.onload = function() {
                    console.log('Original image loaded: ' + originalImage.width + '×' + originalImage.height);
                    createWorkingImages();
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createWorkingImages() {
            if (!originalImage) return;

            showLoading('Creating working images...');

            setTimeout(function() {
                // ワーキングサイズを選択から取得
                const workingSize = parseInt(workingResolutionSelect.value);
                const workingHeight = workingSize / 2;
                
                // ワーキング画像作成
                const workingCanvas = document.createElement('canvas');
                const workingCtx = workingCanvas.getContext('2d');
                workingCanvas.width = workingSize;
                workingCanvas.height = workingHeight;
                workingCtx.drawImage(originalImage, 0, 0, workingSize, workingHeight);
                
                workingImage = new Image();
                workingImage.onload = function() {
                    console.log('Working image created: ' + workingImage.width + '×' + workingImage.height);
                    
                    
                    
// ★プレビュー用キャッシュを1回だけ構築
try {
    const off = document.createElement('canvas');
    off.width = workingImage.width;
    off.height = workingImage.height;
    const ictx = off.getContext('2d', { willReadFrequently: true });
    ictx.drawImage(workingImage, 0, 0);
    workingSourceData = ictx.getImageData(0, 0, off.width, off.height);
} catch (e) {
    console.error('getImageData failed', e);
    workingSourceData = null;
}
                    
                    
                    
                    
                    
                    // ダウンロード画像作成（4096x2048）
                    const downloadCanvas = document.createElement('canvas');
                    const downloadCtx = downloadCanvas.getContext('2d');
                    downloadCanvas.width = 4096;
                    downloadCanvas.height = 2048;
                    downloadCtx.drawImage(originalImage, 0, 0, 4096, 2048);
                    
                    downloadImage = new Image();
                    downloadImage.onload = function() {
                        console.log('Download image created: ' + downloadImage.width + '×' + downloadImage.height);
                        hideLoading();
                        mainContent.style.display = 'block';
                        
                        // 画像読み込み時に初期状態を保存
                        clearHistory();
                        saveState();
                        
                        render();
                    };
                    downloadImage.src = downloadCanvas.toDataURL();
                };
                workingImage.src = workingCanvas.toDataURL();
            }, 100);
        }

        function resetControls() {
            scaleSlider.value = '1.5';
            pitchSlider.value = '0';
            rollSlider.value = '0';
            imgRotateSlider.value = '0';
            
            scaleValue.textContent = '1.5';
            pitchValue.textContent = '0.0°';
            rollValue.textContent = '0.0°';
            imgRotateValue.textContent = '0.0°';
            
            scaleInput.value = '1.5';
            pitchInput.value = '0.0';
            rollInput.value = '0.0';
            imgRotateInput.value = '0.0';
            
            tempScale = 1.5;
            tempPitch = 0;
            tempRoll = 0;
            tempImgRotate = 0;
            
            guidelineRotation = 0;
            document.getElementById('guidelineRotateBtn').style.display = 'none';
            document.getElementById('guidelineSelect').value = 'none';
            
            // リセット時に履歴をクリアして新しい状態を保存
            clearHistory();
            if (workingImage) {
                saveState();
                scheduleRender();
            }
        }

        // スライダーイベント
        scaleSlider.addEventListener('input', function() {
            tempScale = parseFloat(scaleSlider.value);
            scaleValue.textContent = tempScale.toFixed(1);
            scheduleRender();
        });

        pitchSlider.addEventListener('input', function() {
            tempPitch = parseFloat(pitchSlider.value);
            pitchValue.textContent = tempPitch.toFixed(1) + '°';
            scheduleRender();
        });

        rollSlider.addEventListener('input', function() {
            tempRoll = parseFloat(rollSlider.value);
            rollValue.textContent = tempRoll.toFixed(1) + '°';
            scheduleRender();
        });

        imgRotateSlider.addEventListener('input', function() {
            tempImgRotate = parseFloat(imgRotateSlider.value);
            imgRotateValue.textContent = tempImgRotate.toFixed(1) + '°';
            scheduleRender();
        });
        
        
        
        
        
// Scale
scaleSlider.addEventListener('change', function() {
    saveState();
});

// Pitch  
pitchSlider.addEventListener('change', function() {
    saveState();
});

// Roll
rollSlider.addEventListener('change', function() {
    saveState();
});

// ImgRotate
imgRotateSlider.addEventListener('change', function() {
    saveState();
});
        
        
        
        
        
        

        editModeSelect.addEventListener('change', function() {
            const selectedMode = editModeSelect.value;
            isLittlePlanet = (selectedMode === 'little_planet');
            scheduleRender();
        });

        // 数値入力機能
        scaleValue.addEventListener('click', function() { showInput(scaleValue, scaleInput, scaleSlider, false); });
        pitchValue.addEventListener('click', function() { showInput(pitchValue, pitchInput, pitchSlider, true); });
        rollValue.addEventListener('click', function() { showInput(rollValue, rollInput, rollSlider, true); });
        imgRotateValue.addEventListener('click', function() { showInput(imgRotateValue, imgRotateInput, imgRotateSlider, true); });

        function showInput(valueDisplay, input, slider, isDegree) {
            const currentValue = isDegree ? valueDisplay.textContent.replace('°', '') : valueDisplay.textContent;
            input.value = currentValue;
            valueDisplay.style.display = 'none';
            input.style.display = 'inline-block';
            input.focus();
            input.select();
        }

        function hideInput(input, valueDisplay, slider, isDegree) {
            let newValue = parseFloat(input.value);
            if (isNaN(newValue)) {
                newValue = parseFloat(slider.value);
            } else {
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                newValue = Math.max(min, Math.min(max, newValue));
                slider.value = newValue;
            }
            if (isDegree) {
                valueDisplay.textContent = newValue.toFixed(1) + '°';
                if (slider === pitchSlider) tempPitch = newValue;
                else if (slider === rollSlider) tempRoll = newValue;
                else if (slider === imgRotateSlider) tempImgRotate = newValue;
            } else {
                valueDisplay.textContent = newValue.toFixed(1);
                if (slider === scaleSlider) tempScale = newValue;
            }
            input.style.display = 'none';
            valueDisplay.style.display = 'inline-block';
            
            // 数値入力完了時に状態保存
            saveState();
            scheduleRender();
        }

        // 入力フィールドのイベント
        const inputElements = [scaleInput, pitchInput, rollInput, imgRotateInput];
        inputElements.forEach(el => {
            el?.addEventListener('blur', function() {
                const map = new Map([
                    [scaleInput, [scaleValue, scaleSlider, false]],
                    [pitchInput, [pitchValue, pitchSlider, true]],
                    [rollInput, [rollValue, rollSlider, true]],
                    [imgRotateInput, [imgRotateValue, imgRotateSlider, true]]
                ]);
                const [v, s, d] = map.get(el);
                hideInput(el, v, s, d);
            });
            el?.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') el.blur();
            });
        });

        // マウス・タッチ操作（修正版）
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        function normalizeAngle(angle, min, max) {
            const range = max - min;
            let normalized = angle % (range * 2);
            if (normalized > max) normalized -= range * 2;
            else if (normalized < min) normalized += range * 2;
            return Math.max(min, Math.min(max, normalized));
        }

        // 感応領域判定関数（タッチ用）
        function isInActiveArea(touch) {
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            // タッチ位置をcanvas座標に変換
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // 感応領域の設定（例：canvas中央の80%）
            const margin = 0.1; // 10%のマージン
            const activeLeft = rect.width * margin;
            const activeRight = rect.width * (1 - margin);
            const activeTop = rect.height * margin;
            const activeBottom = rect.height * (1 - margin);
            
            return x >= activeLeft && x <= activeRight && 
                   y >= activeTop && y <= activeBottom;
        }

        // 感応領域判定関数（マウス用）
        function isInActiveAreaMouse(event) {
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const margin = 0.1;
            const activeLeft = rect.width * margin;
            const activeRight = rect.width * (1 - margin);
            const activeTop = rect.height * margin;
            const activeBottom = rect.height * (1 - margin);
            
            return x >= activeLeft && x <= activeRight && 
                   y >= activeTop && y <= activeBottom;
        }

        function handleTouchStart(e) {
            e.preventDefault();
            
            // 感応領域チェックを追加
            if (!isInActiveArea(e.touches[0])) {
                return; // 感応領域外なら処理しない
            }
            
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                isPinching = false;
                isMovingCenter = false;
                tempPitch = parseFloat(pitchSlider.value);
                tempRoll = parseFloat(rollSlider.value);
            } else if (e.touches.length === 2) {
                isPinching = true;
                isDragging = false;
                isMovingCenter = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                tempScale = parseFloat(scaleSlider.value);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            // 感応領域チェック
            if (!isDragging && !isPinching && !isMovingCenter) {
                return;
            }            
            
            if (isDragging && e.touches.length === 1) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;

                tempRoll -= deltaX * 0.5;
                tempPitch += deltaY * 0.5;

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                scheduleRender();
            } else if (isPinching && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                const scaleChange = (currentDistance - lastPinchDistance) * 0.01;
                tempScale = Math.max(0.1, Math.min(2.9, tempScale + scaleChange));
                lastPinchDistance = currentDistance;
                scheduleRender();
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (isDragging) {
                tempPitch = normalizeAngle(tempPitch, -180, 180);
                tempRoll = normalizeAngle(tempRoll, -180, 180);
                pitchSlider.value = tempPitch;
                rollSlider.value = tempRoll;
                pitchValue.textContent = tempPitch.toFixed(1) + '°';
                rollValue.textContent = tempRoll.toFixed(1) + '°';
                
                // タッチ操作完了時に状態保存
                saveState();
                scheduleRender();
            } else if (isPinching) {
                scaleSlider.value = tempScale;
                scaleValue.textContent = tempScale.toFixed(1);
                
                // ピンチ操作完了時に状態保存
                saveState();
                scheduleRender();
            }
            isDragging = false;
            isPinching = false;
            isMovingCenter = false;
        }

        function handleMouseDown(e) {
            // マウス用の感応領域チェック
            if (!isInActiveAreaMouse(e)) {
                return;
            }
            
            isDragging = true;
            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
            tempPitch = parseFloat(pitchSlider.value);
            tempRoll = parseFloat(rollSlider.value);
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - lastTouchX;
            const deltaY = e.clientY - lastTouchY;

            tempRoll -= deltaX * 0.5;
            tempPitch += deltaY * 0.5;

            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
            scheduleRender();
        }

        function handleMouseUp(e) {
            if (isDragging) {
                tempPitch = normalizeAngle(tempPitch, -180, 180);
                tempRoll = normalizeAngle(tempRoll, -180, 180);
                pitchSlider.value = tempPitch;
                rollSlider.value = tempRoll;
                pitchValue.textContent = tempPitch.toFixed(1) + '°';
                rollValue.textContent = tempRoll.toFixed(1) + '°';
                
                // マウス操作完了時に状態保存
                saveState();
                scheduleRender();
            }
            isDragging = false;
        }

        // 数学関数
        function sphericalToCartesian(theta, phi) {
            const x = Math.cos(phi) * Math.cos(theta);
            const y = Math.cos(phi) * Math.sin(theta);
            const z = Math.sin(phi);
            return [x, y, z];
        }

        function cartesianToSpherical(x, y, z) {
            const theta = Math.atan2(y, x);
            const phi = Math.asin(Math.max(-1, Math.min(1, z)));
            return [theta, phi];
        }

        function rotatePoint(x, y, z, pitch, roll) {
            const cp = Math.cos(pitch);
            const sp = Math.sin(pitch);
            const cr = Math.cos(roll);
            const sr = Math.sin(roll);

            const rx = x * cr + z * sr;
            const ry = x * sp * sr + y * cp - z * sp * cr;
            const rz = -x * cp * sr + y * sp + z * cp * cr;

            return [rx, ry, rz];
        }

        // レンダリング関数
        function render() {
            if (!workingImage) return;

            const scale = tempScale;
            let pitch = (tempPitch * Math.PI) / 180;
            const roll = (tempRoll * Math.PI) / 180;
            const imgRot = (tempImgRotate * Math.PI) / 180;

            if (!isLittlePlanet) {
                pitch += Math.PI;
            }

const size = getPreviewCanvasSize();
if (canvas.width !== size || canvas.height !== size) {
    canvas.width = size;
    canvas.height = size;
}

            renderBasicMode(size, scale, pitch, roll, imgRot, workingImage);
            drawGuideline();
        }

        function drawGuideline() {
            const selectedType = document.getElementById('guidelineSelect').value;
            if (selectedType === 'none' || !guidelineImages[selectedType]) {
                document.getElementById('guidelineRotateBtn').style.display = 'none';
                return;
            }
            
            document.getElementById('guidelineRotateBtn').style.display = 'block';
            
            const guideline = guidelineImages[selectedType];
            
            ctx.save();
            ctx.globalAlpha = 0.6;
            
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate((guidelineRotation * Math.PI) / 180);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            ctx.drawImage(guideline, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

function renderBasicMode(size, scale, pitch, roll, imgRot, sourceImage) {
    if (!workingSourceData) return; // 画像未準備時の安全策
    const imageData = ctx.createImageData(size, size);
    const data = imageData.data;
    const sourceData = workingSourceData; // ★キャッシュを使用
    const srcW = sourceImage.width;
    const srcH = sourceImage.height;

            const cosA = Math.cos(imgRot);
            const sinA = Math.sin(imgRot);

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const nx0 = (x / (size - 1)) * 2 - 1;
                    const ny0 = (y / (size - 1)) * 2 - 1;

                    // XY回転
                    const rx = nx0 * cosA + ny0 * sinA;
                    const ry = -nx0 * sinA + ny0 * cosA;

                    // 球面効果
                    const r = Math.sqrt(rx * rx + ry * ry);
                    const angle = Math.atan2(ry, rx);
                    const mappedR = 2 * Math.atan(r * (4 - scale));
                    
                    const phi = Math.PI/2 - mappedR;
                    const theta = angle;
                    const cartesian = sphericalToCartesian(theta, phi);

                    // 3D回転
                    const rotated = rotatePoint(cartesian[0], cartesian[1], cartesian[2], pitch, roll);
                    const spherical = cartesianToSpherical(rotated[0], rotated[1], rotated[2]);






const u = (spherical[0] + Math.PI) / (2 * Math.PI);
const v = (spherical[1] + Math.PI / 2) / Math.PI;

// wrap（負値対策込み）
let imgX = Math.floor(u * srcW);
let imgY = Math.floor(v * srcH);
imgX = ((imgX % srcW) + srcW) % srcW;
imgY = ((imgY % srcH) + srcH) % srcH;

if (imgX >= 0 && imgX < srcW && imgY >= 0 && imgY < srcH) {
    const sourceIndex = (imgY * srcW + imgX) * 4;

                        const targetIndex = (y * size + x) * 4;

                        data[targetIndex] = sourceData.data[sourceIndex];
                        data[targetIndex + 1] = sourceData.data[sourceIndex + 1];
                        data[targetIndex + 2] = sourceData.data[sourceIndex + 2];
                        data[targetIndex + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ダウンロード機能（修正版）
function processImageInChunks(canvas, ctx, outputSize, scale, pitch, roll, imgRot, chunkSize, currentY, useBilinear, callback) {
            const endY = Math.min(currentY + chunkSize, outputSize);
            const progress = Math.round((currentY / outputSize) * 100);
            document.getElementById('downloadBtn').textContent = '📄 ' + progress + '%';

            if (!processImageInChunks.sourceData) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = downloadImage.width;
                tempCanvas.height = downloadImage.height;
                tempCtx.drawImage(downloadImage, 0, 0);
                processImageInChunks.sourceData = tempCtx.getImageData(0, 0, downloadImage.width, downloadImage.height);
            }

            const sourceData = processImageInChunks.sourceData;
const srcW = downloadImage.width, srcH = downloadImage.height;

            const chunkHeight = endY - currentY;
            const imageData = ctx.createImageData(outputSize, chunkHeight);
            const data = imageData.data;

            const cosA = Math.cos(imgRot);
            const sinA = Math.sin(imgRot);

            for (let y = 0; y < chunkHeight; y++) {
                for (let x = 0; x < outputSize; x++) {
                    const actualY = currentY + y;
                    const nx0 = (x / (outputSize - 1)) * 2 - 1;
                    const ny0 = (actualY / (outputSize - 1)) * 2 - 1;

                    const rx = nx0 * cosA + ny0 * sinA;
                    const ry = -nx0 * sinA + ny0 * cosA;

                    const r = Math.sqrt(rx * rx + ry * ry);
                    const angle = Math.atan2(ry, rx);
                    const mappedR = 2 * Math.atan(r * (4 - scale));
                    
                    const phi = Math.PI/2 - mappedR;
                    const theta = angle;
                    const cartesian = sphericalToCartesian(theta, phi);

                    const rotated = rotatePoint(cartesian[0], cartesian[1], cartesian[2], pitch, roll);
                    const spherical = cartesianToSpherical(rotated[0], rotated[1], rotated[2]);

const u = (spherical[0] + Math.PI) / (2 * Math.PI);
const v = (spherical[1] + Math.PI / 2) / Math.PI;

const targetIndex = (y * outputSize + x) * 4;
if (useBilinear) {
    // 双線形補間（最小変更: X/Yともwrap）
    let fx = (u * srcW) % srcW; if (fx < 0) fx += srcW;
    let fy = (v * srcH) % srcH; if (fy < 0) fy += srcH;
    const x0 = Math.floor(fx), y0 = Math.floor(fy);
    const x1 = (x0 + 1) % srcW, y1 = (y0 + 1) % srcH;
    const tx = fx - x0, ty = fy - y0;

    const i00 = (y0 * srcW + x0) * 4;
    const i10 = (y0 * srcW + x1) * 4;
    const i01 = (y1 * srcW + x0) * 4;
    const i11 = (y1 * srcW + x1) * 4;

    for (let k = 0; k < 3; k++) {
        const a = sourceData.data[i00 + k] * (1 - tx) + sourceData.data[i10 + k] * tx;
        const b = sourceData.data[i01 + k] * (1 - tx) + sourceData.data[i11 + k] * tx;
        data[targetIndex + k] = (a * (1 - ty) + b * ty) | 0;
    }
    data[targetIndex + 3] = 255;
} else {
    let imgX = Math.floor(u * srcW);
    let imgY = Math.floor(v * srcH);
    imgX = ((imgX % srcW) + srcW) % srcW;
    imgY = ((imgY % srcH) + srcH) % srcH;
    const sourceIndex = (imgY * srcW + imgX) * 4;
    data[targetIndex]     = sourceData.data[sourceIndex];
    data[targetIndex + 1] = sourceData.data[sourceIndex + 1];
    data[targetIndex + 2] = sourceData.data[sourceIndex + 2];
    data[targetIndex + 3] = 255;
}
                }
            }

            ctx.putImageData(imageData, 0, currentY);

            if (endY < outputSize) {
                setTimeout(function() {
processImageInChunks(canvas, ctx, outputSize, scale, pitch, roll, imgRot, chunkSize, endY, useBilinear, callback);
                }, 10);
            } else {
                delete processImageInChunks.sourceData;
                callback();
            }
        }

        // ダウンロードボタンのイベント
        document.getElementById('downloadBtn').addEventListener('click', function() {
            if (!downloadImage) {
                alert('画像が読み込まれていません。');
                return;
            }

const selectedRes = resolutionSelect.value;
const outputSize = parseInt(selectedRes, 10);
const useBilinearExport = selectedRes.includes('+'); // 4K+ のとき true

            const outputFormat = formatSelect.value;
            const scale = parseFloat(scaleSlider.value);
            let pitch = (parseFloat(pitchSlider.value) * Math.PI) / 180;
            const roll = (parseFloat(rollSlider.value) * Math.PI) / 180;
            const imgRot = (parseFloat(imgRotateSlider.value) * Math.PI) / 180;

            if (!isLittlePlanet) {
                pitch += Math.PI;
            }

            console.log('Generating ' + outputSize + '×' + outputSize + ' image...');

            const downloadBtn = document.getElementById('downloadBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.textContent = '📄 Processing...';
            downloadBtn.disabled = true;

            setTimeout(function() {
                try {
                    const downloadCanvas = document.createElement('canvas');
                    const downloadCtx = downloadCanvas.getContext('2d');
                    downloadCanvas.width = outputSize;
                    downloadCanvas.height = outputSize;

                    const chunkSize = outputSize >= 4096 ? 64 : outputSize >= 2048 ? 128 : 256;
                    
processImageInChunks(downloadCanvas, downloadCtx, outputSize, scale, pitch, roll, imgRot, chunkSize, 0, useBilinearExport, function() {
    let resolutionText;
    if (outputSize === 1024) resolutionText = '1K';
    else if (outputSize === 2048) resolutionText = '2K';
    else if (outputSize === 4096) resolutionText = useBilinearExport ? '4K+' : '4K';
    else resolutionText = 'preview';                 
                 
                 
                 
                        const modeText = isLittlePlanet ? 'little_planet' : 'rabbit_hole';
                        
                        const now = new Date();
                        const timestamp = now.getFullYear().toString() + 
                                        (now.getMonth() + 1).toString().padStart(2, '0') + 
                                        now.getDate().toString().padStart(2, '0') + '_' +
                                        now.getHours().toString().padStart(2, '0') + 
                                        now.getMinutes().toString().padStart(2, '0') + 
                                        now.getSeconds().toString().padStart(2, '0');
                        
                        let dataURL;
                        let fileExtension;
                        
                        if (outputFormat === 'jpeg') {
                            dataURL = downloadCanvas.toDataURL('image/jpeg', 0.8);
                            fileExtension = 'jpg';
                        } else {
                            dataURL = downloadCanvas.toDataURL('image/png');
                            fileExtension = 'png';
                        }
                        
                        const filename = modeText + '_' + resolutionText + '_imgRot' + (parseFloat(imgRotateSlider.value)||0).toFixed(0) + '_' + timestamp + '.' + fileExtension;

                        const link = document.createElement('a');
                        link.download = filename;
                        link.href = dataURL;
                        link.click();

                        downloadBtn.textContent = originalText;
                        downloadBtn.disabled = false;
                    });
                } catch (error) {
                    console.error('Download failed:', error);
                    alert('ダウンロードに失敗しました。メモリ不足の可能性があります。');
                    downloadBtn.textContent = originalText;
                    downloadBtn.disabled = false;
                }
            }, 100);
        });
        
        // ランダム化機能
        /* ランダム化機能はコメント化　2025/08/25
        function randomizeAllSliders() {
            const sliderConfigs = [
                { id: 'scaleSlider', valueId: 'scaleValue', inputId: 'scaleInput', unit: '', tempVar: 'tempScale' },
                { id: 'pitchSlider', valueId: 'pitchValue', inputId: 'pitchInput', unit: '°', tempVar: 'tempPitch' },
                { id: 'rollSlider', valueId: 'rollValue', inputId: 'rollInput', unit: '°', tempVar: 'tempRoll' },
                { id: 'imgRotateSlider', valueId: 'imgRotateValue', inputId: 'imgRotateInput', unit: '°', tempVar: 'tempImgRotate' }
            ];
        
            sliderConfigs.forEach(config => {
                const slider = document.getElementById(config.id);
                const valueDisplay = document.getElementById(config.valueId);
                const inputField = document.getElementById(config.inputId);
                
                if (slider) {
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const step = parseFloat(slider.step);
                    
                    const range = (max - min) / step;
                    const randomSteps = Math.floor(Math.random() * (range + 1));
                    const randomValue = min + (randomSteps * step);
                    
                    slider.value = randomValue;
                    
                    if (valueDisplay) {
                        valueDisplay.textContent = randomValue.toFixed(1) + config.unit;
                    }
                    if (inputField) {
                        inputField.value = randomValue.toFixed(1) + (config.unit === '°' ? '' : '');
                    }
                    
                    switch(config.tempVar) {
                        case 'tempScale': tempScale = randomValue; break;
                        case 'tempPitch': tempPitch = randomValue; break;
                        case 'tempRoll': tempRoll = randomValue; break;
                        case 'tempImgRotate': tempImgRotate = randomValue; break;
                    }
                }
            });
            
            // ランダム化時に状態保存
            saveState();
            scheduleRender();
        }
        
        // ランダムボタンのイベント
        document.getElementById('randomBtn').addEventListener('click', randomizeAllSliders);
        */
        
function incrementSlider(sliderId) {
    const slider = document.getElementById(sliderId);
    const currentValue = parseFloat(slider.value);
    const step = parseFloat(slider.step);
    const max = parseFloat(slider.max);
    
    const newValue = Math.min(max, currentValue + step);
    slider.value = newValue;
    
    // スライダーのinputイベントを発火
    slider.dispatchEvent(new Event('input'));
    
        // 状態保存を追加
    saveState();
}

function decrementSlider(sliderId) {
    const slider = document.getElementById(sliderId);
    const currentValue = parseFloat(slider.value);
    const step = parseFloat(slider.step);
    const min = parseFloat(slider.min);
    
    const newValue = Math.max(min, currentValue - step);
    slider.value = newValue;
    
    // スライダーのinputイベントを発火
    slider.dispatchEvent(new Event('input'));
    
        // 状態保存を追加
    saveState();
}
        
    </script>
</body>
</html>
