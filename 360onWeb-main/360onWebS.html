<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360onWeb - Fixed</title>
    <style>
        :root {
            --bg-gradient-start: #9e3c72;
            --bg-gradient-end: #2a5298;
            --slider-grdnt-start: #4CAF50;
            --slider-grdnt-end: #2196F3;
            --upload-area-border--: 3px dashed #4CAF50;
            --upload-area-bg--: rgba(255,255,255,0.1);
            --upload-hover-border--: #45a049;
            --upload-hover-bg--: rgba(255,255,255,0.15);
            --upload-dragover-border--: #2196F3;
            --upload-dragover-bg--: rgba(33,150,243,0.2);
            --upload-btn--: #4CAF50;
            --upload-btn-hover--: #45a049;
            --random-btn--: #FF6B6B;
            --download-btn-bg--: linear-gradient(45deg, #667eea, #764ba2);
            --download-btn-hover--: rgba(0,0,0,0.3);
            --undo-btn-bg--: linear-gradient(45deg, #FF6B6B, #FFB347);
            --undo-btn-hover--: rgba(255,107,107,0.3);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
            color: white;
            min-height: 100vh;
        }
    
        .container {
            max-width: 1524px;
            margin: 0 auto;
        }
    
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-size: 24px;
        }

        .upload-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: nowrap;
        }
    
        .app-title {
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        
        .upload-area {
            border: var(--upload-area-border--);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            background: var(--upload-area-bg--);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
    
        .upload-area:hover {
            border-color: var(--upload-hover-border--);
            background: var(--upload-hover-bg--);
        }
    
        .upload-area.dragover {
            border-color: var(--upload-dragover-border--);
            background: var(--upload-dragover-bg--);
        }
    
        input[type="file"] {
            display: none;
        }
    
        .upload-btn {
            background: var(--upload-btn--);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
            white-space: nowrap;
        }
    
        .upload-btn:hover {
            background: var(--upload-btn-hover--);
        }
    
        .random-btn {
            width: 5%;
            background: transparent;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 32px;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .random-btn:hover {
            transform: scale(1.1);
        }
    
        .main-content {
            display: none;
        }
    
        .editor-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }
    
        .canvas-container {
            flex: 1;
            text-align: center;
        }
    
        .canvas-wrapper {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            position: relative;
        }
    
        canvas {
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 100%;
            height: auto;
            touch-action: none;
            cursor: grab;
        }
    
        canvas:active {
            cursor: grabbing;
        }
    
        .controls {
            width: 300px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
    
        .control-group {
            margin-bottom: 18px;
        }
    
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
            color: #f0f0f0;
        }
    
        .label-text {
            text-align: left;
        }
    
        .value-display {
            font-size: 14px;
            color: #ddd;
            text-align: right;
            min-width: 70px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
    
        .value-display:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }
    
        .value-input {
            font-size: 14px;
            color: white;
            text-align: right;
            min-width: 70px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #4CAF50;
            border-radius: 4px;
            padding: 2px 6px;
            outline: none;
        }
    
        .slider-container {
            position: relative;
        }
        
        .slider-with-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-btn {
            width: 30px;
            height: 30px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .slider-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }

        .slider-with-buttons input[type="range"] {
            flex: 1;
        }
    
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--slider-grdnt-start), var(--slider-grdnt-end));
            outline: none;
            -webkit-appearance: none;
        }
    
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
    
        .download-btn {
            width: 100%;
            background: var(--download-btn-bg--);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
    
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--download-btn-hover--);
        }
    
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
    
        .loading-content {
            text-align: center;
            color: white;
            font-size: 18px;
        }
    
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
    
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    
        .touch-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }
        
        .guideline-rotate-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            z-index: 15;
            transition: background 0.3s;
        }

        .guideline-rotate-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .guideline-select {
            padding: 8px 12px;
            border-radius: 5px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
            min-width: 100px;
            flex-shrink: 0;
        }
        
        .guideline-select:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .guideline-select option {
            background: #333;
            color: white;
        }
        
        
        
        
/* Undo/Redoã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.undo-redo-overlay {
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 10;
}

.undo-btn-overlay {
    width: 50px;
    height: 25px;
    background: rgba(255,107,107,0.4);
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 20px;
    font-weight: 600;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
}

.undo-btn-overlay:not(:disabled):hover {
    background: rgba(255,107,107,1);
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(255,107,107,0.4);
}

.undo-btn-overlay:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    background: rgba(128,128,128,0.2);
}

#redoBtn.undo-btn-overlay {
    background: rgba(76,175,80,0.4);
}

#redoBtn.undo-btn-overlay:not(:disabled):hover {
    background: rgba(76,175,80,1);
    box-shadow: 0 4px 12px rgba(76,175,80,0.4);
}
        
        
        
        
        
.icon-btn{
  /* è¦‹ãˆãªã„â€œå††å½¢ãƒ’ãƒƒãƒˆé ˜åŸŸâ€ã¯æ®‹ã™ï¼ˆå½“ãŸã‚Šåˆ¤å®šï¼†ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãƒªãƒ³ã‚°ç”¨ï¼‰ */
  width: 40px; height: 40px;
  display: grid; place-items: center;
  border: none; border-radius: 50%;
  background: transparent; color: #fff;
  cursor: pointer; outline: none;
/* è¿½åŠ ï¼šã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã«é‡ã­ã‚‹ */
position: absolute;
top: 10px;
left: 10px;
z-index: 15;
}

.icon-btn .emoji{
  font-size: 22px; line-height: 1;   /* è¡Œãƒœãƒƒã‚¯ã‚¹ã®å½±éŸ¿ã‚’æ’é™¤ */
  opacity: .65;                       /* â† çµµæ–‡å­—ã‚’åŠé€æ˜ã«ã™ã‚‹ãƒã‚¤ãƒ³ãƒˆ */
  transform: translateY(var(--nudge-y, 0)); /* ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³å¾®èª¿æ•´ç”¨ï¼ˆå¿…è¦æ™‚ã®ã¿ï¼‰ */
}

/* ãƒ›ãƒãƒ¼/ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã®è¦–èªæ€§ï¼ˆå††ã¯â€œè¦‹ãˆãªã„/æ·¡ã„â€ã ã‘ã§æ®‹ã™ï¼‰ */
.icon-btn:hover { background: rgba(255,255,255,0.08); }
.icon-btn:active{ background: rgba(255,255,255,0.14); }
.icon-btn:focus-visible{
  box-shadow: 0 0 0 2px rgba(255,255,255,.35);
}

  
        
        

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        @media screen and (orientation: portrait) {
            .container {
                display: flex;
                flex-direction: column;
                width: 100%;
                margin: 0 auto;
            }
            
            .upload-area {
                width: 100% !important;
                margin-bottom: 20px;
                box-sizing: border-box;
            }
            
            .editor-container {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            
            .canvas-container {
                width: 100% !important;
                box-sizing: border-box;
            }
            
            .controls {
                width: 100% !important;
                margin: 0;
                box-sizing: border-box;
            }
            
            .canvas-wrapper {
                padding: 15px;
                box-sizing: border-box;
            }
            
            .controls {
                padding: 20px;
                box-sizing: border-box;
            }
        }

        @media screen and (orientation: landscape) {
            .container {
                display: flex;
                flex-direction: column;
            }
            
            .upload-area {
                width: 96%;
                margin-bottom: 20px;
                order: -1;
            }
            
            .editor-container {
                display: flex;
                flex-direction: row;
                gap: 20px;
            }
            
            .canvas-container {
                flex: 1;
                width: 50%;
            }
            
            .controls {
                flex: 1;
                width: 50%;
                margin: 0;
            }
        }

        @media (max-width: 768px) {
            .editor-container {
                gap: 10px;
            }
            
            .canvas-wrapper {
                padding: 15px;
            }
            
            .controls {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="upload-area" id="uploadArea">
            <div class="upload-header">
                <button class="upload-btn" onclick="resetControlsAndSelectFile()">
                    ğŸ–¼ï¸+360onWeb
                </button>
                <select id="guidelineSelect" class="guideline-select">
                    <option value="none">ã‚¬ã‚¤ãƒ‰ãªã—(1ï½16)</option>
                    <option value="line01"> 1.åŒå¿ƒå††</option>
                    <option value="line02"> 2.ä¸‰é‡å††</option>
                    <option value="line03"> 3.å††åˆ†å‰²</option>
                    <option value="line04"> 4.ã—ã¼ã‚Š</option>
                    <option value="line05"> 5.æ¸¦å·»ã</option>
                    <option value="line06"> 6.ä¸‰åˆ†å‰²</option>
                    <option value="line07"> 7.å››åˆ†å‰²</option>
                    <option value="line08"> 8.æ”¾å°„åˆ†å‰²</option>
                    <option value="line09"> 9.æ–œã‚åˆ†å‰²</option>
                    <option value="line10">10.é è¿‘æ–œã‚</option>
                    <option value="line11">11.é è¿‘æ°´å¹³</option>
                    <option value="line12">12.ãƒ•ã‚£ãƒœãƒŠãƒƒãƒ</option>
                    <option value="line13">13.Så­—</option>
                    <option value="line14">14.Uå­—</option>
                    <option value="line15">15.äºŒã¤çª“</option>
                    <option value="line16">16.é›»å½±ã‚¯ãƒ­ã‚¹ã‚²ãƒ¼ã‚¸</option>
                </select>
                <button class="random-btn" id="randomBtn">ğŸ¤¯</button>
            </div>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="main-content" id="mainContent">
            <div class="editor-container">
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <canvas id="canvas" width="720" height="720"></canvas>
                
<!--                        <button id="guidelineRotateBtn" class="guideline-rotate-btn" style="display: none;">ğŸ”„</button>-->
                
                
<button id="guidelineRotateBtn" class="icon-btn" aria-label="ã‚¬ã‚¤ãƒ‰å›è»¢" title="å›è»¢(45Â°)">
<span class="emoji" aria-hidden="true">ğŸ”„</span>
</button>
                
                
                        <div class="touch-indicator" id="touchIndicator">Move Center</div>
                        
                        
                            <!-- ã“ã®éƒ¨åˆ†ã‚’è¿½åŠ  -->
    <div class="undo-redo-overlay">
        <button class="undo-btn-overlay" id="undoBtn" disabled>â†º</button>
        <button class="undo-btn-overlay" id="redoBtn" disabled>â†»</button>
    </div>
                        
                        
                    </div>

                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <div class="control-label">
                            <span class="label-text">ğŸ” Zoom æ‹¡å¤§ç¸®å°</span>
                            <input type="text" class="value-input" id="scaleInput" value="1.5" style="display: none;">
                            <span class="value-display" id="scaleValue">1.5</span>
                        </div>
                        <div class="slider-container">
                            <div class="slider-with-buttons">
                                <button class="slider-btn" onclick="decrementSlider('scaleSlider')">âˆ’</button>
                                <input type="range" id="scaleSlider" min="0.1" max="2.9" step="0.1" value="1.5">
                                <button class="slider-btn" onclick="incrementSlider('scaleSlider')">+</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span class="label-text">Pitch ãƒ”ãƒƒãƒ</span>
                            <input type="text" class="value-input" id="pitchInput" value="0Â°" style="display: none;">
                            <span class="value-display" id="pitchValue">0.0Â°</span>
                        </div>
                        <div class="slider-container">
                            <div class="slider-with-buttons">
                                <button class="slider-btn" onclick="incrementSlider('pitchSlider')">âˆ’</button>
                                <input type="range" id="pitchSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                                <button class="slider-btn" onclick="decrementSlider('pitchSlider')">+</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label">
                            <span class="label-text">Roll ãƒ­ãƒ¼ãƒ«</span>
                            <input type="text" class="value-input" id="rollInput" value="0Â°" style="display: none;">
                            <span class="value-display" id="rollValue">0.0Â°</span>
                        </div>
                        <div class="slider-container">
                            <div class="slider-with-buttons">
                                <button class="slider-btn" onclick="incrementSlider('rollSlider')">âˆ’</button>
                                <input type="range" id="rollSlider" min="-180" max="180" step="1" value="0" style="transform: scaleX(-1);">
                                <button class="slider-btn" onclick="decrementSlider('rollSlider')">+</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span class="label-text">ğŸ”ƒ Rotate å›è»¢</span>
                            <input type="text" class="value-input" id="imgRotateInput" value="0Â°" style="display: none;">
                            <span class="value-display" id="imgRotateValue">0.0Â°</span>
                        </div>
                        <div class="slider-container">
                            <div class="slider-with-buttons">
                                <button class="slider-btn" onclick="decrementSlider('imgRotateSlider')">âˆ’</button>
                                <input type="range" id="imgRotateSlider" min="-180" max="180" step="1" value="0">
                                <button class="slider-btn" onclick="incrementSlider('imgRotateSlider')">+</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;"> 
                        <label for="editModeSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        Edit type
                        </label>
                        <select id="editModeSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="little_planet" style="background: #333; color: white;">Little Planet</option>
                            <option value="rabbit_hole" style="background: #333; color: white;">Rabbit Hole</option>
                        </select>
                    </div>

                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;"> 
                        <label for="formatSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        Format type
                        </label>
                        <select id="formatSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="jpeg" style="background: #333; color: white;">JPG 80%</option>
                            <option value="png" style="background: #333; color: white;">PNG</option>
                        </select>
                    </div>

                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <label for="resolutionSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        Export size
                        </label>
                        <select id="resolutionSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="1024" style="background: #333; color: white;">1024Ã—1024 (1K)</option>
                            <option value="2048" style="background: #333; color: white;">2048Ã—2048 (2K)</option>
                            <option value="4096" style="background: #333; color: white;">4096Ã—4096 (4K)</option>
                            <option value="4096+" style="background: #333; color: white;">4096Ã—4096 (+4K)</option>

                        </select>
                    </div>

                    <div class="control-group" style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <label for="workingResolutionSelect" style="color: white; font-size: 14px; white-space: nowrap; min-width: 120px;">
                        Preview Res.
                        </label>
                        <select id="workingResolutionSelect" style="flex: 1; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 14px;">
                            <option value="256" style="background: #333; color: white;">Quickï¼ˆé€Ÿåº¦é‡è¦–ï¼‰</option>
                            <option value="512" style="background: #333; color: white;" selected>Balancedï¼ˆæ¨™æº–ï¼‰</option>
                            <option value="1024" style="background: #333; color: white;">Detailedï¼ˆè¡¨ç¤ºé‡è¦–ï¼‰</option>
                        </select>
                    </div>
                    
                    <button class="download-btn" id="downloadBtn">ğŸ“‚ Download</button>
                </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div id="loadingText">Processing image...</div>
        </div>
    </div>

    <script>
        let originalImage = null;
        let workingImage = null;
        let downloadImage = null;
        let isLittlePlanet = true;
        let guidelineImages = {};
        let guidelineRotation = 0;
        
        
// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã® getImageData ã‚’æ’é™¤ï¼‰
let workingSourceData = null;
// å…¥åŠ›ã‚’1ãƒ•ãƒ¬ãƒ¼ãƒ ã«åˆæµ
let framePending = false;
        

        // Undoæ©Ÿèƒ½ç”¨ã®å¤‰æ•°
        let stateHistory = [];
        let currentStateIndex = -1;
        const MAX_HISTORY = 20; // æœ€å¤§20å›ã¾ã§ã®Undoã‚’ä¿å­˜

        const guidelineTypes = ['line01', 'line02', 'line03', 'line04', 'line05', 'line06', 'line07', 'line08', 'line09', 'line10', 'line11', 'line12', 'line13', 'line14', 'line15', 'line16'];

        // DOMè¦ç´ ã®å–å¾—

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const mainContent = document.getElementById('mainContent');
        const touchIndicator = document.getElementById('touchIndicator');

        const scaleSlider = document.getElementById('scaleSlider');
        const pitchSlider = document.getElementById('pitchSlider');
        const rollSlider = document.getElementById('rollSlider');
        const imgRotateSlider = document.getElementById('imgRotateSlider');
        const editModeSelect = document.getElementById('editModeSelect');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const formatSelect = document.getElementById('formatSelect');
        const workingResolutionSelect = document.getElementById('workingResolutionSelect');

        const scaleValue = document.getElementById('scaleValue');
        const pitchValue = document.getElementById('pitchValue');
        const rollValue = document.getElementById('rollValue');
        const imgRotateValue = document.getElementById('imgRotateValue');

        const scaleInput = document.getElementById('scaleInput');
        const pitchInput = document.getElementById('pitchInput');
        const rollInput = document.getElementById('rollInput');
        const imgRotateInput = document.getElementById('imgRotateInput');

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');


        // ã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹æ“ä½œç”¨å¤‰æ•°
        let isDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let lastPinchDistance = 0;
        let isPinching = false;
        let isMovingCenter = false;
        let tempScale = parseFloat(scaleSlider.value) || 1.5;
        let tempPitch = parseFloat(pitchSlider.value) || 0;
        let tempRoll = parseFloat(rollSlider.value) || 0;
        let tempImgRotate = parseFloat(imgRotateSlider.value) || 0;


// rAF åˆæµ
function scheduleRender() {
    if (framePending) return;
    framePending = true;
    requestAnimationFrame(() => { framePending = false; render(); });
}

// Display size ã«é€£å‹•ã—ãŸãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è§£åƒåº¦ï¼ˆè»½é‡åŒ–ï¼‰
function getPreviewCanvasSize() {
    const s = parseInt(workingResolutionSelect.value, 10); // 256/512/1024
    if (s <= 256) return 384;   // Fast
    if (s <= 512) return 720;   // Standardï¼ˆå¾“æ¥ï¼‰
    return 960;                 // Qualityï¼ˆã¾ã è»½ã„ï¼‰
}


// Display sizeã®ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿æ©Ÿèƒ½
function saveDisplaySize() {
    const selectedSize = workingResolutionSelect.value;
    localStorage.setItem('360onweb_displaySize', selectedSize);
}

function loadDisplaySize() {
    const savedSize = localStorage.getItem('360onweb_displaySize');
    if (savedSize && workingResolutionSelect) {
        // ä¿å­˜ã•ã‚ŒãŸå€¤ãŒé¸æŠè‚¢ã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        const options = Array.from(workingResolutionSelect.options).map(opt => opt.value);
        if (options.includes(savedSize)) {
            workingResolutionSelect.value = savedSize;
        }
    }
}





        // Undoæ©Ÿèƒ½ã®å®Ÿè£…
        function saveState() {
            const state = {
                scale: tempScale,
                pitch: tempPitch,
                roll: tempRoll,
                imgRotate: tempImgRotate
            };
            
            // ç¾åœ¨ã®ä½ç½®ä»¥é™ã®å±¥æ­´ã‚’å‰Šé™¤ï¼ˆæ–°ã—ã„æ“ä½œãŒã‚ã£ãŸå ´åˆï¼‰
            stateHistory = stateHistory.slice(0, currentStateIndex + 1);
            
            // æ–°ã—ã„çŠ¶æ…‹ã‚’è¿½åŠ 
            stateHistory.push(state);
            currentStateIndex++;
            
            // å±¥æ­´ã®ä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€å¤ã„å±¥æ­´ã‚’å‰Šé™¤
            if (stateHistory.length > MAX_HISTORY) {
                stateHistory.shift();
                currentStateIndex--;
            }
            
            updateUndoRedoButtons();
        }

        function undo() {
            if (currentStateIndex > 0) {
                currentStateIndex--;
                const state = stateHistory[currentStateIndex];
                restoreState(state);
                updateUndoRedoButtons();
            }
        }
        
        // Redoé–¢æ•°
function redo() {
    if (currentStateIndex < stateHistory.length - 1) {
        currentStateIndex++;                           // å±¥æ­´ã‚’1ã¤é€²ã‚ã‚‹
        const state = stateHistory[currentStateIndex]; // æ¬¡ã®çŠ¶æ…‹ã‚’å–å¾—
        restoreState(state);                          // çŠ¶æ…‹ã‚’å¾©å…ƒ
        updateUndoRedoButtons();                      // ãƒœã‚¿ãƒ³ã®æ›´æ–°
    }
}

        function restoreState(state) {
            // å€¤ã‚’å¾©å…ƒ
            tempScale = state.scale;
            tempPitch = state.pitch;
            tempRoll = state.roll;
            tempImgRotate = state.imgRotate;
            
            // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’æ›´æ–°
            scaleSlider.value = tempScale;
            pitchSlider.value = tempPitch;
            rollSlider.value = tempRoll;
            imgRotateSlider.value = tempImgRotate;
            
            // è¡¨ç¤ºå€¤ã‚’æ›´æ–°
            scaleValue.textContent = tempScale.toFixed(1);
            pitchValue.textContent = tempPitch.toFixed(1) + 'Â°';
            rollValue.textContent = tempRoll.toFixed(1) + 'Â°';
            imgRotateValue.textContent = tempImgRotate.toFixed(1) + 'Â°';
            
            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚‚æ›´æ–°
            scaleInput.value = tempScale.toFixed(1);
            pitchInput.value = tempPitch.toFixed(1);
            rollInput.value = tempRoll.toFixed(1);
            imgRotateInput.value = tempImgRotate.toFixed(1);
            
// å†æç”»
scheduleRender();
        }


// ãƒœã‚¿ãƒ³æ›´æ–°é–¢æ•°ã‚’ä¿®æ­£
function updateUndoRedoButtons() {
    undoBtn.disabled = currentStateIndex <= 0;
    redoBtn.disabled = currentStateIndex >= stateHistory.length - 1;
}



        function clearHistory() {
            stateHistory = [];
            currentStateIndex = -1;
            updateUndoRedoButtons();
        }

        window.addEventListener('load', function() {
// Display sizeã®å¾©å…ƒã‚’å…ˆã«
loadDisplaySize();
loadSampleImage();
loadGuidelineImages();
            
            const guidelineSelect = document.getElementById('guidelineSelect');
            guidelineSelect.addEventListener('change', function() {
                guidelineRotation = 0;
                scheduleRender();
            });

            document.getElementById('guidelineRotateBtn').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                guidelineRotation = (guidelineRotation + 45) % 360;
                scheduleRender();
            });

            // ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ã‚µã‚¤ã‚ºå¤‰æ›´ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            workingResolutionSelect.addEventListener('change', function() {
                if (originalImage) {
                    createWorkingImages();
                }
// ä¿å­˜æ©Ÿèƒ½ã‚’è¿½åŠ 
saveDisplaySize();
            });

            // Undoãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

        });

        function showLoading(text) {
            const overlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = text;
            overlay.style.display = 'flex';
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = 'none';
        }

        function loadSampleImage() {
            if (location.protocol === 'file:') {
                console.log('Local environment detected. Sample image loading skipped.');
                return;
            }
            const sampleImage = new Image();
            sampleImage.onload = function() {
                originalImage = sampleImage;
                createWorkingImages();
            };
            sampleImage.onerror = function() {
                console.log('sample4k.jpg is not available. select 360 image');
            };
            sampleImage.src = './sample4k.jpg';
        }
        
        // æ§‹å›³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ç”»åƒã®èª­ã¿è¾¼ã¿
        function loadGuidelineImages() {
            if (location.protocol === 'file:') {
                console.log('Local environment detected. Guideline images loading skipped.');
                return;
            }
        
            guidelineTypes.forEach(type => {
                const img = new Image();
                img.onload = function() {
                    guidelineImages[type] = img;
                    console.log(`Guideline image loaded: ${type}`);
                };
                img.onerror = function() {
                    console.log(`Guideline image not found: lines/${type}.png`);
                };
                img.src = `./lines/${type}.png`;
            });
        }

        function resetControlsAndSelectFile() {
            resetControls();
            document.getElementById('fileInput').click();
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
        fileInput.addEventListener('change', handleFile);
        
        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function() {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                resetControls();
                processFile(files[0]);
            }
        });

        function handleFile(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼');
                return;
            }

            showLoading('Loading image...');

            const reader = new FileReader();
            reader.onload = function(e) {
                originalImage = new Image();
                originalImage.onload = function() {
                    console.log('Original image loaded: ' + originalImage.width + 'Ã—' + originalImage.height);
                    createWorkingImages();
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createWorkingImages() {
            if (!originalImage) return;

            showLoading('Creating working images...');

            setTimeout(function() {
                // ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ã‚µã‚¤ã‚ºã‚’é¸æŠã‹ã‚‰å–å¾—
                const workingSize = parseInt(workingResolutionSelect.value);
                const workingHeight = workingSize / 2;
                
                // ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ç”»åƒä½œæˆ
                const workingCanvas = document.createElement('canvas');
                const workingCtx = workingCanvas.getContext('2d');
                workingCanvas.width = workingSize;
                workingCanvas.height = workingHeight;
                workingCtx.drawImage(originalImage, 0, 0, workingSize, workingHeight);
                
                workingImage = new Image();
                workingImage.onload = function() {
                    console.log('Working image created: ' + workingImage.width + 'Ã—' + workingImage.height);
                    
                    
                    
// â˜…ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’1å›ã ã‘æ§‹ç¯‰
try {
    const off = document.createElement('canvas');
    off.width = workingImage.width;
    off.height = workingImage.height;
    const ictx = off.getContext('2d', { willReadFrequently: true });
    ictx.drawImage(workingImage, 0, 0);
    workingSourceData = ictx.getImageData(0, 0, off.width, off.height);
} catch (e) {
    console.error('getImageData failed', e);
    workingSourceData = null;
}
                    
                    
                    
                    
                    
                    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”»åƒä½œæˆï¼ˆ4096x2048ï¼‰
                    const downloadCanvas = document.createElement('canvas');
                    const downloadCtx = downloadCanvas.getContext('2d');
                    downloadCanvas.width = 4096;
                    downloadCanvas.height = 2048;
                    downloadCtx.drawImage(originalImage, 0, 0, 4096, 2048);
                    
                    downloadImage = new Image();
                    downloadImage.onload = function() {
                        console.log('Download image created: ' + downloadImage.width + 'Ã—' + downloadImage.height);
                        hideLoading();
                        mainContent.style.display = 'block';
                        
                        // ç”»åƒèª­ã¿è¾¼ã¿æ™‚ã«åˆæœŸçŠ¶æ…‹ã‚’ä¿å­˜
                        clearHistory();
                        saveState();
                        
                        render();
                    };
                    downloadImage.src = downloadCanvas.toDataURL();
                };
                workingImage.src = workingCanvas.toDataURL();
            }, 100);
        }

        function resetControls() {
            scaleSlider.value = '1.5';
            pitchSlider.value = '0';
            rollSlider.value = '0';
            imgRotateSlider.value = '0';
            
            scaleValue.textContent = '1.5';
            pitchValue.textContent = '0.0Â°';
            rollValue.textContent = '0.0Â°';
            imgRotateValue.textContent = '0.0Â°';
            
            scaleInput.value = '1.5';
            pitchInput.value = '0.0';
            rollInput.value = '0.0';
            imgRotateInput.value = '0.0';
            
            tempScale = 1.5;
            tempPitch = 0;
            tempRoll = 0;
            tempImgRotate = 0;
            
            guidelineRotation = 0;
            document.getElementById('guidelineRotateBtn').style.display = 'none';
            document.getElementById('guidelineSelect').value = 'none';
            
            // ãƒªã‚»ãƒƒãƒˆæ™‚ã«å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã—ã¦æ–°ã—ã„çŠ¶æ…‹ã‚’ä¿å­˜
            clearHistory();
            if (workingImage) {
                saveState();
                scheduleRender();
            }
        }

        // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
        scaleSlider.addEventListener('input', function() {
            tempScale = parseFloat(scaleSlider.value);
            scaleValue.textContent = tempScale.toFixed(1);
            scheduleRender();
        });

        pitchSlider.addEventListener('input', function() {
            tempPitch = parseFloat(pitchSlider.value);
            pitchValue.textContent = tempPitch.toFixed(1) + 'Â°';
            scheduleRender();
        });

        rollSlider.addEventListener('input', function() {
            tempRoll = parseFloat(rollSlider.value);
            rollValue.textContent = tempRoll.toFixed(1) + 'Â°';
            scheduleRender();
        });

        imgRotateSlider.addEventListener('input', function() {
            tempImgRotate = parseFloat(imgRotateSlider.value);
            imgRotateValue.textContent = tempImgRotate.toFixed(1) + 'Â°';
            scheduleRender();
        });
        
        
        
        
        
// Scale
scaleSlider.addEventListener('change', function() {
    saveState();
});

// Pitch  
pitchSlider.addEventListener('change', function() {
    saveState();
});

// Roll
rollSlider.addEventListener('change', function() {
    saveState();
});

// ImgRotate
imgRotateSlider.addEventListener('change', function() {
    saveState();
});
        
        
        
        
        
        

        editModeSelect.addEventListener('change', function() {
            const selectedMode = editModeSelect.value;
            isLittlePlanet = (selectedMode === 'little_planet');
            scheduleRender();
        });

        // æ•°å€¤å…¥åŠ›æ©Ÿèƒ½
        scaleValue.addEventListener('click', function() { showInput(scaleValue, scaleInput, scaleSlider, false); });
        pitchValue.addEventListener('click', function() { showInput(pitchValue, pitchInput, pitchSlider, true); });
        rollValue.addEventListener('click', function() { showInput(rollValue, rollInput, rollSlider, true); });
        imgRotateValue.addEventListener('click', function() { showInput(imgRotateValue, imgRotateInput, imgRotateSlider, true); });

        function showInput(valueDisplay, input, slider, isDegree) {
            const currentValue = isDegree ? valueDisplay.textContent.replace('Â°', '') : valueDisplay.textContent;
            input.value = currentValue;
            valueDisplay.style.display = 'none';
            input.style.display = 'inline-block';
            input.focus();
            input.select();
        }

        function hideInput(input, valueDisplay, slider, isDegree) {
            let newValue = parseFloat(input.value);
            if (isNaN(newValue)) {
                newValue = parseFloat(slider.value);
            } else {
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                newValue = Math.max(min, Math.min(max, newValue));
                slider.value = newValue;
            }
            if (isDegree) {
                valueDisplay.textContent = newValue.toFixed(1) + 'Â°';
                if (slider === pitchSlider) tempPitch = newValue;
                else if (slider === rollSlider) tempRoll = newValue;
                else if (slider === imgRotateSlider) tempImgRotate = newValue;
            } else {
                valueDisplay.textContent = newValue.toFixed(1);
                if (slider === scaleSlider) tempScale = newValue;
            }
            input.style.display = 'none';
            valueDisplay.style.display = 'inline-block';
            
            // æ•°å€¤å…¥åŠ›å®Œäº†æ™‚ã«çŠ¶æ…‹ä¿å­˜
            saveState();
            scheduleRender();
        }

        // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        const inputElements = [scaleInput, pitchInput, rollInput, imgRotateInput];
        inputElements.forEach(el => {
            el?.addEventListener('blur', function() {
                const map = new Map([
                    [scaleInput, [scaleValue, scaleSlider, false]],
                    [pitchInput, [pitchValue, pitchSlider, true]],
                    [rollInput, [rollValue, rollSlider, true]],
                    [imgRotateInput, [imgRotateValue, imgRotateSlider, true]]
                ]);
                const [v, s, d] = map.get(el);
                hideInput(el, v, s, d);
            });
            el?.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') el.blur();
            });
        });

        // ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒæ“ä½œï¼ˆä¿®æ­£ç‰ˆï¼‰
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        function normalizeAngle(angle, min, max) {
            const range = max - min;
            let normalized = angle % (range * 2);
            if (normalized > max) normalized -= range * 2;
            else if (normalized < min) normalized += range * 2;
            return Math.max(min, Math.min(max, normalized));
        }

        // æ„Ÿå¿œé ˜åŸŸåˆ¤å®šé–¢æ•°ï¼ˆã‚¿ãƒƒãƒç”¨ï¼‰
        function isInActiveArea(touch) {
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            // ã‚¿ãƒƒãƒä½ç½®ã‚’canvasåº§æ¨™ã«å¤‰æ›
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // æ„Ÿå¿œé ˜åŸŸã®è¨­å®šï¼ˆä¾‹ï¼šcanvasä¸­å¤®ã®80%ï¼‰
            const margin = 0.1; // 10%ã®ãƒãƒ¼ã‚¸ãƒ³
            const activeLeft = rect.width * margin;
            const activeRight = rect.width * (1 - margin);
            const activeTop = rect.height * margin;
            const activeBottom = rect.height * (1 - margin);
            
            return x >= activeLeft && x <= activeRight && 
                   y >= activeTop && y <= activeBottom;
        }

        // æ„Ÿå¿œé ˜åŸŸåˆ¤å®šé–¢æ•°ï¼ˆãƒã‚¦ã‚¹ç”¨ï¼‰
        function isInActiveAreaMouse(event) {
            const canvas = document.getElementById('canvas');
            const rect = canvas.getBoundingClientRect();
            
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const margin = 0.1;
            const activeLeft = rect.width * margin;
            const activeRight = rect.width * (1 - margin);
            const activeTop = rect.height * margin;
            const activeBottom = rect.height * (1 - margin);
            
            return x >= activeLeft && x <= activeRight && 
                   y >= activeTop && y <= activeBottom;
        }

        function handleTouchStart(e) {
            e.preventDefault();
            
            // æ„Ÿå¿œé ˜åŸŸãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
            if (!isInActiveArea(e.touches[0])) {
                return; // æ„Ÿå¿œé ˜åŸŸå¤–ãªã‚‰å‡¦ç†ã—ãªã„
            }
            
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                isPinching = false;
                isMovingCenter = false;
                tempPitch = parseFloat(pitchSlider.value);
                tempRoll = parseFloat(rollSlider.value);
            } else if (e.touches.length === 2) {
                isPinching = true;
                isDragging = false;
                isMovingCenter = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                tempScale = parseFloat(scaleSlider.value);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            // æ„Ÿå¿œé ˜åŸŸãƒã‚§ãƒƒã‚¯
            if (!isDragging && !isPinching && !isMovingCenter) {
                return;
            }            
            
            if (isDragging && e.touches.length === 1) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;

                tempRoll -= deltaX * 0.5;
                tempPitch += deltaY * 0.5;

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                scheduleRender();
            } else if (isPinching && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                const scaleChange = (currentDistance - lastPinchDistance) * 0.01;
                tempScale = Math.max(0.1, Math.min(2.9, tempScale + scaleChange));
                lastPinchDistance = currentDistance;
                scheduleRender();
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (isDragging) {
                tempPitch = normalizeAngle(tempPitch, -180, 180);
                tempRoll = normalizeAngle(tempRoll, -180, 180);
                pitchSlider.value = tempPitch;
                rollSlider.value = tempRoll;
                pitchValue.textContent = tempPitch.toFixed(1) + 'Â°';
                rollValue.textContent = tempRoll.toFixed(1) + 'Â°';
                
                // ã‚¿ãƒƒãƒæ“ä½œå®Œäº†æ™‚ã«çŠ¶æ…‹ä¿å­˜
                saveState();
                scheduleRender();
            } else if (isPinching) {
                scaleSlider.value = tempScale;
                scaleValue.textContent = tempScale.toFixed(1);
                
                // ãƒ”ãƒ³ãƒæ“ä½œå®Œäº†æ™‚ã«çŠ¶æ…‹ä¿å­˜
                saveState();
                scheduleRender();
            }
            isDragging = false;
            isPinching = false;
            isMovingCenter = false;
        }

        function handleMouseDown(e) {
            // ãƒã‚¦ã‚¹ç”¨ã®æ„Ÿå¿œé ˜åŸŸãƒã‚§ãƒƒã‚¯
            if (!isInActiveAreaMouse(e)) {
                return;
            }
            
            isDragging = true;
            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
            tempPitch = parseFloat(pitchSlider.value);
            tempRoll = parseFloat(rollSlider.value);
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - lastTouchX;
            const deltaY = e.clientY - lastTouchY;

            tempRoll -= deltaX * 0.5;
            tempPitch += deltaY * 0.5;

            lastTouchX = e.clientX;
            lastTouchY = e.clientY;
            scheduleRender();
        }

        function handleMouseUp(e) {
            if (isDragging) {
                tempPitch = normalizeAngle(tempPitch, -180, 180);
                tempRoll = normalizeAngle(tempRoll, -180, 180);
                pitchSlider.value = tempPitch;
                rollSlider.value = tempRoll;
                pitchValue.textContent = tempPitch.toFixed(1) + 'Â°';
                rollValue.textContent = tempRoll.toFixed(1) + 'Â°';
                
                // ãƒã‚¦ã‚¹æ“ä½œå®Œäº†æ™‚ã«çŠ¶æ…‹ä¿å­˜
                saveState();
                scheduleRender();
            }
            isDragging = false;
        }

        // æ•°å­¦é–¢æ•°
        function sphericalToCartesian(theta, phi) {
            const x = Math.cos(phi) * Math.cos(theta);
            const y = Math.cos(phi) * Math.sin(theta);
            const z = Math.sin(phi);
            return [x, y, z];
        }

        function cartesianToSpherical(x, y, z) {
            const theta = Math.atan2(y, x);
            const phi = Math.asin(Math.max(-1, Math.min(1, z)));
            return [theta, phi];
        }

        function rotatePoint(x, y, z, pitch, roll) {
            const cp = Math.cos(pitch);
            const sp = Math.sin(pitch);
            const cr = Math.cos(roll);
            const sr = Math.sin(roll);

            const rx = x * cr + z * sr;
            const ry = x * sp * sr + y * cp - z * sp * cr;
            const rz = -x * cp * sr + y * sp + z * cp * cr;

            return [rx, ry, rz];
        }

        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°
        function render() {
            if (!workingImage) return;

            const scale = tempScale;
            let pitch = (tempPitch * Math.PI) / 180;
            const roll = (tempRoll * Math.PI) / 180;
            const imgRot = (tempImgRotate * Math.PI) / 180;

            if (!isLittlePlanet) {
                pitch += Math.PI;
            }

const size = getPreviewCanvasSize();
if (canvas.width !== size || canvas.height !== size) {
    canvas.width = size;
    canvas.height = size;
}

            renderBasicMode(size, scale, pitch, roll, imgRot, workingImage);
            drawGuideline();
        }

        function drawGuideline() {
            const selectedType = document.getElementById('guidelineSelect').value;
            if (selectedType === 'none' || !guidelineImages[selectedType]) {
                document.getElementById('guidelineRotateBtn').style.display = 'none';
                return;
            }
            
            document.getElementById('guidelineRotateBtn').style.display = 'block';
            
            const guideline = guidelineImages[selectedType];
            
            ctx.save();
            ctx.globalAlpha = 0.6;
            
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate((guidelineRotation * Math.PI) / 180);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            ctx.drawImage(guideline, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

function renderBasicMode(size, scale, pitch, roll, imgRot, sourceImage) {
    if (!workingSourceData) return; // ç”»åƒæœªæº–å‚™æ™‚ã®å®‰å…¨ç­–
    const imageData = ctx.createImageData(size, size);
    const data = imageData.data;
    const sourceData = workingSourceData; // â˜…ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨
    const srcW = sourceImage.width;
    const srcH = sourceImage.height;

            const cosA = Math.cos(imgRot);
            const sinA = Math.sin(imgRot);

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const nx0 = (x / (size - 1)) * 2 - 1;
                    const ny0 = (y / (size - 1)) * 2 - 1;

                    // XYå›è»¢
                    const rx = nx0 * cosA + ny0 * sinA;
                    const ry = -nx0 * sinA + ny0 * cosA;

                    // çƒé¢åŠ¹æœ
                    const r = Math.sqrt(rx * rx + ry * ry);
                    const angle = Math.atan2(ry, rx);
                    const mappedR = 2 * Math.atan(r * (4 - scale));
                    
                    const phi = Math.PI/2 - mappedR;
                    const theta = angle;
                    const cartesian = sphericalToCartesian(theta, phi);

                    // 3Då›è»¢
                    const rotated = rotatePoint(cartesian[0], cartesian[1], cartesian[2], pitch, roll);
                    const spherical = cartesianToSpherical(rotated[0], rotated[1], rotated[2]);






const u = (spherical[0] + Math.PI) / (2 * Math.PI);
const v = (spherical[1] + Math.PI / 2) / Math.PI;

// wrapï¼ˆè² å€¤å¯¾ç­–è¾¼ã¿ï¼‰
let imgX = Math.floor(u * srcW);
let imgY = Math.floor(v * srcH);
imgX = ((imgX % srcW) + srcW) % srcW;
imgY = ((imgY % srcH) + srcH) % srcH;

if (imgX >= 0 && imgX < srcW && imgY >= 0 && imgY < srcH) {
    const sourceIndex = (imgY * srcW + imgX) * 4;

                        const targetIndex = (y * size + x) * 4;

                        data[targetIndex] = sourceData.data[sourceIndex];
                        data[targetIndex + 1] = sourceData.data[sourceIndex + 1];
                        data[targetIndex + 2] = sourceData.data[sourceIndex + 2];
                        data[targetIndex + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ï¼ˆä¿®æ­£ç‰ˆï¼‰
function processImageInChunks(canvas, ctx, outputSize, scale, pitch, roll, imgRot, chunkSize, currentY, useBilinear, callback) {
            const endY = Math.min(currentY + chunkSize, outputSize);
            const progress = Math.round((currentY / outputSize) * 100);
            document.getElementById('downloadBtn').textContent = 'ğŸ“„ ' + progress + '%';

            if (!processImageInChunks.sourceData) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = downloadImage.width;
                tempCanvas.height = downloadImage.height;
                tempCtx.drawImage(downloadImage, 0, 0);
                processImageInChunks.sourceData = tempCtx.getImageData(0, 0, downloadImage.width, downloadImage.height);
            }

            const sourceData = processImageInChunks.sourceData;
const srcW = downloadImage.width, srcH = downloadImage.height;

            const chunkHeight = endY - currentY;
            const imageData = ctx.createImageData(outputSize, chunkHeight);
            const data = imageData.data;

            const cosA = Math.cos(imgRot);
            const sinA = Math.sin(imgRot);

            for (let y = 0; y < chunkHeight; y++) {
                for (let x = 0; x < outputSize; x++) {
                    const actualY = currentY + y;
                    const nx0 = (x / (outputSize - 1)) * 2 - 1;
                    const ny0 = (actualY / (outputSize - 1)) * 2 - 1;

                    const rx = nx0 * cosA + ny0 * sinA;
                    const ry = -nx0 * sinA + ny0 * cosA;

                    const r = Math.sqrt(rx * rx + ry * ry);
                    const angle = Math.atan2(ry, rx);
                    const mappedR = 2 * Math.atan(r * (4 - scale));
                    
                    const phi = Math.PI/2 - mappedR;
                    const theta = angle;
                    const cartesian = sphericalToCartesian(theta, phi);

                    const rotated = rotatePoint(cartesian[0], cartesian[1], cartesian[2], pitch, roll);
                    const spherical = cartesianToSpherical(rotated[0], rotated[1], rotated[2]);

const u = (spherical[0] + Math.PI) / (2 * Math.PI);
const v = (spherical[1] + Math.PI / 2) / Math.PI;

const targetIndex = (y * outputSize + x) * 4;
if (useBilinear) {
    // åŒç·šå½¢è£œé–“ï¼ˆæœ€å°å¤‰æ›´: X/Yã¨ã‚‚wrapï¼‰
    let fx = (u * srcW) % srcW; if (fx < 0) fx += srcW;
    let fy = (v * srcH) % srcH; if (fy < 0) fy += srcH;
    const x0 = Math.floor(fx), y0 = Math.floor(fy);
    const x1 = (x0 + 1) % srcW, y1 = (y0 + 1) % srcH;
    const tx = fx - x0, ty = fy - y0;

    const i00 = (y0 * srcW + x0) * 4;
    const i10 = (y0 * srcW + x1) * 4;
    const i01 = (y1 * srcW + x0) * 4;
    const i11 = (y1 * srcW + x1) * 4;

    for (let k = 0; k < 3; k++) {
        const a = sourceData.data[i00 + k] * (1 - tx) + sourceData.data[i10 + k] * tx;
        const b = sourceData.data[i01 + k] * (1 - tx) + sourceData.data[i11 + k] * tx;
        data[targetIndex + k] = (a * (1 - ty) + b * ty) | 0;
    }
    data[targetIndex + 3] = 255;
} else {
    let imgX = Math.floor(u * srcW);
    let imgY = Math.floor(v * srcH);
    imgX = ((imgX % srcW) + srcW) % srcW;
    imgY = ((imgY % srcH) + srcH) % srcH;
    const sourceIndex = (imgY * srcW + imgX) * 4;
    data[targetIndex]     = sourceData.data[sourceIndex];
    data[targetIndex + 1] = sourceData.data[sourceIndex + 1];
    data[targetIndex + 2] = sourceData.data[sourceIndex + 2];
    data[targetIndex + 3] = 255;
}
                }
            }

            ctx.putImageData(imageData, 0, currentY);

            if (endY < outputSize) {
                setTimeout(function() {
processImageInChunks(canvas, ctx, outputSize, scale, pitch, roll, imgRot, chunkSize, endY, useBilinear, callback);
                }, 10);
            } else {
                delete processImageInChunks.sourceData;
                callback();
            }
        }

        // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('downloadBtn').addEventListener('click', function() {
            if (!downloadImage) {
                alert('ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
                return;
            }

const selectedRes = resolutionSelect.value;
const outputSize = parseInt(selectedRes, 10);
const useBilinearExport = selectedRes.includes('+'); // 4K+ ã®ã¨ã true

            const outputFormat = formatSelect.value;
            const scale = parseFloat(scaleSlider.value);
            let pitch = (parseFloat(pitchSlider.value) * Math.PI) / 180;
            const roll = (parseFloat(rollSlider.value) * Math.PI) / 180;
            const imgRot = (parseFloat(imgRotateSlider.value) * Math.PI) / 180;

            if (!isLittlePlanet) {
                pitch += Math.PI;
            }

            console.log('Generating ' + outputSize + 'Ã—' + outputSize + ' image...');

            const downloadBtn = document.getElementById('downloadBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.textContent = 'ğŸ“„ Processing...';
            downloadBtn.disabled = true;

            setTimeout(function() {
                try {
                    const downloadCanvas = document.createElement('canvas');
                    const downloadCtx = downloadCanvas.getContext('2d');
                    downloadCanvas.width = outputSize;
                    downloadCanvas.height = outputSize;

                    const chunkSize = outputSize >= 4096 ? 64 : outputSize >= 2048 ? 128 : 256;
                    
processImageInChunks(downloadCanvas, downloadCtx, outputSize, scale, pitch, roll, imgRot, chunkSize, 0, useBilinearExport, function() {
    let resolutionText;
    if (outputSize === 1024) resolutionText = '1K';
    else if (outputSize === 2048) resolutionText = '2K';
    else if (outputSize === 4096) resolutionText = useBilinearExport ? '4K+' : '4K';
    else resolutionText = 'preview';                 
                 
                 
                 
                        const modeText = isLittlePlanet ? 'little_planet' : 'rabbit_hole';
                        
                        const now = new Date();
                        const timestamp = now.getFullYear().toString() + 
                                        (now.getMonth() + 1).toString().padStart(2, '0') + 
                                        now.getDate().toString().padStart(2, '0') + '_' +
                                        now.getHours().toString().padStart(2, '0') + 
                                        now.getMinutes().toString().padStart(2, '0') + 
                                        now.getSeconds().toString().padStart(2, '0');
                        
                        let dataURL;
                        let fileExtension;
                        
                        if (outputFormat === 'jpeg') {
                            dataURL = downloadCanvas.toDataURL('image/jpeg', 0.8);
                            fileExtension = 'jpg';
                        } else {
                            dataURL = downloadCanvas.toDataURL('image/png');
                            fileExtension = 'png';
                        }
                        
                        const filename = modeText + '_' + resolutionText + '_imgRot' + (parseFloat(imgRotateSlider.value)||0).toFixed(0) + '_' + timestamp + '.' + fileExtension;

                        const link = document.createElement('a');
                        link.download = filename;
                        link.href = dataURL;
                        link.click();

                        downloadBtn.textContent = originalText;
                        downloadBtn.disabled = false;
                    });
                } catch (error) {
                    console.error('Download failed:', error);
                    alert('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ¡ãƒ¢ãƒªä¸è¶³ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
                    downloadBtn.textContent = originalText;
                    downloadBtn.disabled = false;
                }
            }, 100);
        });
        
        // ãƒ©ãƒ³ãƒ€ãƒ åŒ–æ©Ÿèƒ½
        function randomizeAllSliders() {
            const sliderConfigs = [
                { id: 'scaleSlider', valueId: 'scaleValue', inputId: 'scaleInput', unit: '', tempVar: 'tempScale' },
                { id: 'pitchSlider', valueId: 'pitchValue', inputId: 'pitchInput', unit: 'Â°', tempVar: 'tempPitch' },
                { id: 'rollSlider', valueId: 'rollValue', inputId: 'rollInput', unit: 'Â°', tempVar: 'tempRoll' },
                { id: 'imgRotateSlider', valueId: 'imgRotateValue', inputId: 'imgRotateInput', unit: 'Â°', tempVar: 'tempImgRotate' }
            ];
        
            sliderConfigs.forEach(config => {
                const slider = document.getElementById(config.id);
                const valueDisplay = document.getElementById(config.valueId);
                const inputField = document.getElementById(config.inputId);
                
                if (slider) {
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const step = parseFloat(slider.step);
                    
                    const range = (max - min) / step;
                    const randomSteps = Math.floor(Math.random() * (range + 1));
                    const randomValue = min + (randomSteps * step);
                    
                    slider.value = randomValue;
                    
                    if (valueDisplay) {
                        valueDisplay.textContent = randomValue.toFixed(1) + config.unit;
                    }
                    if (inputField) {
                        inputField.value = randomValue.toFixed(1) + (config.unit === 'Â°' ? '' : '');
                    }
                    
                    switch(config.tempVar) {
                        case 'tempScale': tempScale = randomValue; break;
                        case 'tempPitch': tempPitch = randomValue; break;
                        case 'tempRoll': tempRoll = randomValue; break;
                        case 'tempImgRotate': tempImgRotate = randomValue; break;
                    }
                }
            });
            
            // ãƒ©ãƒ³ãƒ€ãƒ åŒ–æ™‚ã«çŠ¶æ…‹ä¿å­˜
            saveState();
            scheduleRender();
        }
        
        // ãƒ©ãƒ³ãƒ€ãƒ ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('randomBtn').addEventListener('click', randomizeAllSliders);
        
        
function incrementSlider(sliderId) {
    const slider = document.getElementById(sliderId);
    const currentValue = parseFloat(slider.value);
    const step = parseFloat(slider.step);
    const max = parseFloat(slider.max);
    
    const newValue = Math.min(max, currentValue + step);
    slider.value = newValue;
    
    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®inputã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
    slider.dispatchEvent(new Event('input'));
    
        // çŠ¶æ…‹ä¿å­˜ã‚’è¿½åŠ 
    saveState();
}

function decrementSlider(sliderId) {
    const slider = document.getElementById(sliderId);
    const currentValue = parseFloat(slider.value);
    const step = parseFloat(slider.step);
    const min = parseFloat(slider.min);
    
    const newValue = Math.max(min, currentValue - step);
    slider.value = newValue;
    
    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®inputã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
    slider.dispatchEvent(new Event('input'));
    
        // çŠ¶æ…‹ä¿å­˜ã‚’è¿½åŠ 
    saveState();
}
        
    </script>
</body>
</html>
